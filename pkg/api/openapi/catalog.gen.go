// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
	OAuth2Scopes     = "OAuth2.Scopes"
)

// Defines values for NotificationType.
const (
	CREATE   NotificationType = "CREATE"
	DROP     NotificationType = "DROP"
	UNKNOWN  NotificationType = "UNKNOWN"
	UPDATE   NotificationType = "UPDATE"
	VALIDATE NotificationType = "VALIDATE"
)

// Defines values for NullOrder.
const (
	NullsFirst NullOrder = "nulls-first"
	NullsLast  NullOrder = "nulls-last"
)

// Defines values for OAuthClientCredentialsRequestGrantType.
const (
	ClientCredentials OAuthClientCredentialsRequestGrantType = "client_credentials"
)

// Defines values for OAuthErrorError.
const (
	InvalidClient        OAuthErrorError = "invalid_client"
	InvalidGrant         OAuthErrorError = "invalid_grant"
	InvalidRequest       OAuthErrorError = "invalid_request"
	InvalidScope         OAuthErrorError = "invalid_scope"
	UnauthorizedClient   OAuthErrorError = "unauthorized_client"
	UnsupportedGrantType OAuthErrorError = "unsupported_grant_type"
)

// Defines values for OAuthTokenExchangeRequestGrantType.
const (
	UrnIetfParamsOauthGrantTypeTokenExchange OAuthTokenExchangeRequestGrantType = "urn:ietf:params:oauth:grant-type:token-exchange"
)

// Defines values for OAuthTokenResponseTokenType.
const (
	Bearer OAuthTokenResponseTokenType = "bearer"
	Mac    OAuthTokenResponseTokenType = "mac"
	NA     OAuthTokenResponseTokenType = "N_A"
)

// Defines values for PolicyAttachmentTargetType.
const (
	PolicyAttachmentTargetTypeCatalog   PolicyAttachmentTargetType = "catalog"
	PolicyAttachmentTargetTypeNamespace PolicyAttachmentTargetType = "namespace"
	PolicyAttachmentTargetTypeTableLike PolicyAttachmentTargetType = "table-like"
)

// Defines values for SetSnapshotRefUpdateType.
const (
	SetSnapshotRefUpdateTypeBranch SetSnapshotRefUpdateType = "branch"
	SetSnapshotRefUpdateTypeTag    SetSnapshotRefUpdateType = "tag"
)

// Defines values for SnapshotSummaryOperation.
const (
	Append    SnapshotSummaryOperation = "append"
	Delete    SnapshotSummaryOperation = "delete"
	Overwrite SnapshotSummaryOperation = "overwrite"
	Replace   SnapshotSummaryOperation = "replace"
)

// Defines values for SnapshotReferenceType.
const (
	SnapshotReferenceTypeBranch SnapshotReferenceType = "branch"
	SnapshotReferenceTypeTag    SnapshotReferenceType = "tag"
)

// Defines values for SortDirection.
const (
	Asc  SortDirection = "asc"
	Desc SortDirection = "desc"
)

// Defines values for TokenType.
const (
	UrnIetfParamsOauthTokenTypeAccessToken  TokenType = "urn:ietf:params:oauth:token-type:access_token"
	UrnIetfParamsOauthTokenTypeIdToken      TokenType = "urn:ietf:params:oauth:token-type:id_token"
	UrnIetfParamsOauthTokenTypeJwt          TokenType = "urn:ietf:params:oauth:token-type:jwt"
	UrnIetfParamsOauthTokenTypeRefreshToken TokenType = "urn:ietf:params:oauth:token-type:refresh_token"
	UrnIetfParamsOauthTokenTypeSaml1        TokenType = "urn:ietf:params:oauth:token-type:saml1"
	UrnIetfParamsOauthTokenTypeSaml2        TokenType = "urn:ietf:params:oauth:token-type:saml2"
)

// Defines values for DataAccess.
const (
	DataAccessRemoteSigning     DataAccess = "remote-signing"
	DataAccessVendedCredentials DataAccess = "vended-credentials"
)

// Defines values for CreateTableParamsXIcebergAccessDelegation.
const (
	CreateTableParamsXIcebergAccessDelegationRemoteSigning     CreateTableParamsXIcebergAccessDelegation = "remote-signing"
	CreateTableParamsXIcebergAccessDelegationVendedCredentials CreateTableParamsXIcebergAccessDelegation = "vended-credentials"
)

// Defines values for LoadTableParamsSnapshots.
const (
	All  LoadTableParamsSnapshots = "all"
	Refs LoadTableParamsSnapshots = "refs"
)

// Defines values for LoadTableParamsXIcebergAccessDelegation.
const (
	RemoteSigning     LoadTableParamsXIcebergAccessDelegation = "remote-signing"
	VendedCredentials LoadTableParamsXIcebergAccessDelegation = "vended-credentials"
)

// AddPartitionSpecUpdate defines model for AddPartitionSpecUpdate.
type AddPartitionSpecUpdate = BaseUpdate

// AddSchemaUpdate defines model for AddSchemaUpdate.
type AddSchemaUpdate = BaseUpdate

// AddSnapshotUpdate defines model for AddSnapshotUpdate.
type AddSnapshotUpdate = BaseUpdate

// AddSortOrderUpdate defines model for AddSortOrderUpdate.
type AddSortOrderUpdate = BaseUpdate

// AddViewVersionUpdate defines model for AddViewVersionUpdate.
type AddViewVersionUpdate = BaseUpdate

// AndOrExpression defines model for AndOrExpression.
type AndOrExpression struct {
	Left  Expression     `json:"left"`
	Right Expression     `json:"right"`
	Type  ExpressionType `json:"type"`
}

// ApplicablePolicy defines model for ApplicablePolicy.
type ApplicablePolicy struct {
	Content     *string `json:"content,omitempty"`
	Description *string `json:"description,omitempty"`
	Inheritable bool    `json:"inheritable"`
	Inherited   bool    `json:"inherited"`

	// Name A policy name. A valid policy name should only consist of uppercase and lowercase letters (A-Z, a-z), digits (0-9), hyphens (-), underscores (_).
	Name PolicyName `json:"name"`

	// Namespace Reference to one or more levels of a namespace
	Namespace  Namespace `json:"namespace"`
	PolicyType string    `json:"policy-type"`
	Version    int       `json:"version"`
}

// AssertViewUUID The view UUID must match the requirement's `uuid`
type AssertViewUUID struct {
	Type string `json:"type"`
	Uuid string `json:"uuid"`
}

// AssignUUIDUpdate defines model for AssignUUIDUpdate.
type AssignUUIDUpdate = BaseUpdate

// AttachPolicyRequest defines model for AttachPolicyRequest.
type AttachPolicyRequest struct {
	Parameters *map[string]string     `json:"parameters,omitempty"`
	Target     PolicyAttachmentTarget `json:"target"`
}

// BaseUpdate defines model for BaseUpdate.
type BaseUpdate struct {
	Action string `json:"action"`
}

// BinaryTypeValue Binary type values are stored and serialized as an uppercase hexadecimal string
type BinaryTypeValue = string

// BlobMetadata defines model for BlobMetadata.
type BlobMetadata struct {
	Fields         []int              `json:"fields"`
	Properties     *map[string]string `json:"properties,omitempty"`
	SequenceNumber int64              `json:"sequence-number"`
	SnapshotId     int64              `json:"snapshot-id"`
	Type           string             `json:"type"`
}

// BooleanTypeValue defines model for BooleanTypeValue.
type BooleanTypeValue = bool

// CatalogConfig Server-provided configuration for the catalog.
type CatalogConfig struct {
	// Defaults Properties that should be used as default configuration; applied before client configuration.
	Defaults map[string]string `json:"defaults"`

	// Endpoints A list of endpoints that the server supports. The format of each endpoint must be "<HTTP verb> <resource path from OpenAPI REST spec>". The HTTP verb and the resource path must be separated by a space character.
	Endpoints *[]string `json:"endpoints,omitempty"`

	// Overrides Properties that should be used to override client configuration; applied after defaults and client configuration.
	Overrides map[string]string `json:"overrides"`
}

// CommitReport defines model for CommitReport.
type CommitReport struct {
	Metadata       *map[string]string `json:"metadata,omitempty"`
	Metrics        Metrics            `json:"metrics"`
	Operation      string             `json:"operation"`
	SequenceNumber int64              `json:"sequence-number"`
	SnapshotId     int64              `json:"snapshot-id"`
	TableName      string             `json:"table-name"`
}

// CommitTableRequest defines model for CommitTableRequest.
type CommitTableRequest struct {
	Identifier   *TableIdentifier   `json:"identifier,omitempty"`
	Requirements []TableRequirement `json:"requirements"`
	Updates      []TableUpdate      `json:"updates"`
}

// CommitTableResponse defines model for CommitTableResponse.
type CommitTableResponse struct {
	Metadata         TableMetadata `json:"metadata"`
	MetadataLocation string        `json:"metadata-location"`
}

// CommitTransactionRequest defines model for CommitTransactionRequest.
type CommitTransactionRequest struct {
	TableChanges []CommitTableRequest `json:"table-changes"`
}

// CommitViewRequest defines model for CommitViewRequest.
type CommitViewRequest struct {
	Identifier   *TableIdentifier   `json:"identifier,omitempty"`
	Requirements *[]ViewRequirement `json:"requirements,omitempty"`
	Updates      []ViewUpdate       `json:"updates"`
}

// CounterResult defines model for CounterResult.
type CounterResult struct {
	Unit  string `json:"unit"`
	Value int64  `json:"value"`
}

// CreateGenericTableRequest defines model for CreateGenericTableRequest.
type CreateGenericTableRequest struct {
	BaseLocation *string            `json:"base-location,omitempty"`
	Doc          *string            `json:"doc,omitempty"`
	Format       string             `json:"format"`
	Name         string             `json:"name"`
	Properties   *map[string]string `json:"properties,omitempty"`
}

// CreateNamespaceRequest defines model for CreateNamespaceRequest.
type CreateNamespaceRequest struct {
	// Namespace Reference to one or more levels of a namespace
	Namespace Namespace `json:"namespace"`

	// Properties Configured string to string map of properties for the namespace
	Properties *map[string]string `json:"properties,omitempty"`
}

// CreateNamespaceResponse defines model for CreateNamespaceResponse.
type CreateNamespaceResponse struct {
	// Namespace Reference to one or more levels of a namespace
	Namespace Namespace `json:"namespace"`

	// Properties Properties stored on the namespace, if supported by the server.
	Properties *map[string]string `json:"properties,omitempty"`
}

// CreatePolicyRequest defines model for CreatePolicyRequest.
type CreatePolicyRequest struct {
	Content     *string `json:"content,omitempty"`
	Description *string `json:"description,omitempty"`

	// Name A policy name. A valid policy name should only consist of uppercase and lowercase letters (A-Z, a-z), digits (0-9), hyphens (-), underscores (_).
	Name PolicyName `json:"name"`
	Type string     `json:"type"`
}

// CreateTableRequest defines model for CreateTableRequest.
type CreateTableRequest struct {
	Location      *string            `json:"location,omitempty"`
	Name          string             `json:"name"`
	PartitionSpec *PartitionSpec     `json:"partition-spec,omitempty"`
	Properties    *map[string]string `json:"properties,omitempty"`
	Schema        Schema             `json:"schema"`
	StageCreate   *bool              `json:"stage-create,omitempty"`
	WriteOrder    *SortOrder         `json:"write-order,omitempty"`
}

// CreateViewRequest defines model for CreateViewRequest.
type CreateViewRequest struct {
	Location    *string           `json:"location,omitempty"`
	Name        string            `json:"name"`
	Properties  map[string]string `json:"properties"`
	Schema      Schema            `json:"schema"`
	ViewVersion ViewVersion       `json:"view-version"`
}

// DateTypeValue Date type values follow the 'YYYY-MM-DD' ISO-8601 standard date format
type DateTypeValue = openapi_types.Date

// DecimalTypeValue Decimal type values are serialized as strings. Decimals with a positive scale serialize as numeric plain  text, while decimals with a negative scale use scientific notation and the exponent will be equal to the  negated scale. For instance, a decimal with a positive scale is '123.4500', with zero scale is '2',  and with a negative scale is '2E+20'
type DecimalTypeValue = string

// DetachPolicyRequest defines model for DetachPolicyRequest.
type DetachPolicyRequest struct {
	Target PolicyAttachmentTarget `json:"target"`
}

// DoubleTypeValue defines model for DoubleTypeValue.
type DoubleTypeValue = float64

// EnableRowLineageUpdate defines model for EnableRowLineageUpdate.
type EnableRowLineageUpdate = BaseUpdate

// ErrorModel JSON error payload returned in a response with further details on the error
type ErrorModel struct {
	// Code HTTP response code
	Code int `json:"code"`

	// Message Human-readable error message
	Message string    `json:"message"`
	Stack   *[]string `json:"stack,omitempty"`

	// Type Internal type definition of the error
	Type string `json:"type"`
}

// Expression defines model for Expression.
type Expression struct {
	union json.RawMessage
}

// ExpressionType defines model for ExpressionType.
type ExpressionType = string

// FalseExpression defines model for FalseExpression.
type FalseExpression struct {
	Type ExpressionType `json:"type"`
}

// FixedTypeValue Fixed length type values are stored and serialized as an uppercase hexadecimal string  preserving the fixed length
type FixedTypeValue = string

// FloatTypeValue defines model for FloatTypeValue.
type FloatTypeValue = float32

// GenericTable Generic Table information.
// - `name` (REQUIRED): name for the generic table
// - `format` (REQUIRED): format for the generic table, i.e. "delta", "csv"
// - `base-location` (OPTIONAL): table base location in URI format. For example: s3://<my-bucket>/path/to/table.
//   - The table base location is a location that includes all files for the table.
//   - A table with multiple disjoint locations (i.e. containing files that are outside the configured base location) is not compliant with the current generic table support in Polaris.
//   - If no location is provided, clients or users are responsible for managing the location.
//
// - `properties` (OPTIONAL): properties for the generic table passed on creation
// - `doc` (OPTIONAL): comment or description for the generic table
type GenericTable struct {
	BaseLocation *string            `json:"base-location,omitempty"`
	Doc          *string            `json:"doc,omitempty"`
	Format       string             `json:"format"`
	Name         string             `json:"name"`
	Properties   *map[string]string `json:"properties,omitempty"`
}

// GetApplicablePoliciesResponse defines model for GetApplicablePoliciesResponse.
type GetApplicablePoliciesResponse struct {
	ApplicablePolicies []ApplicablePolicy `json:"applicable-policies"`

	// NextPageToken An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter `pageToken` to the server.
	// Servers that support pagination should identify the `pageToken` parameter and return a `next-page-token` in the response if there are more results available.  After the initial request, the value of `next-page-token` from each response must be used as the `pageToken` parameter value for the next request. The server must return `null` value for the `next-page-token` in the last response.
	// Servers that support pagination must return all results in a single response with the value of `next-page-token` set to `null` if the query parameter `pageToken` is not set in the request.
	// Servers that do not support pagination should ignore the `pageToken` parameter and return all results in a single response. The `next-page-token` must be omitted from the response.
	// Clients must interpret either `null` or missing response value of `next-page-token` as the end of the listing results.
	NextPageToken *PageToken `json:"next-page-token"`
}

// GetNamespaceResponse defines model for GetNamespaceResponse.
type GetNamespaceResponse struct {
	// Namespace Reference to one or more levels of a namespace
	Namespace Namespace `json:"namespace"`

	// Properties Properties stored on the namespace, if supported by the server. If the server does not support namespace properties, it should return null for this field. If namespace properties are supported, but none are set, it should return an empty object.
	Properties *map[string]string `json:"properties"`
}

// IcebergErrorResponse JSON wrapper for all error responses (non-2xx)
type IcebergErrorResponse struct {
	// Error JSON error payload returned in a response with further details on the error
	Error ErrorModel `json:"error"`
}

// IntegerTypeValue defines model for IntegerTypeValue.
type IntegerTypeValue = int

// ListGenericTablesResponse defines model for ListGenericTablesResponse.
type ListGenericTablesResponse struct {
	Identifiers *[]TableIdentifier `json:"identifiers,omitempty"`

	// NextPageToken An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter `pageToken` to the server.
	// Servers that support pagination should identify the `pageToken` parameter and return a `next-page-token` in the response if there are more results available.  After the initial request, the value of `next-page-token` from each response must be used as the `pageToken` parameter value for the next request. The server must return `null` value for the `next-page-token` in the last response.
	// Servers that support pagination must return all results in a single response with the value of `next-page-token` set to `null` if the query parameter `pageToken` is not set in the request.
	// Servers that do not support pagination should ignore the `pageToken` parameter and return all results in a single response. The `next-page-token` must be omitted from the response.
	// Clients must interpret either `null` or missing response value of `next-page-token` as the end of the listing results.
	NextPageToken *PageToken `json:"next-page-token"`
}

// ListNamespacesResponse defines model for ListNamespacesResponse.
type ListNamespacesResponse struct {
	Namespaces *[]Namespace `json:"namespaces,omitempty"`

	// NextPageToken An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter `pageToken` to the server.
	// Servers that support pagination should identify the `pageToken` parameter and return a `next-page-token` in the response if there are more results available.  After the initial request, the value of `next-page-token` from each response must be used as the `pageToken` parameter value for the next request. The server must return `null` value for the `next-page-token` in the last response.
	// Servers that support pagination must return all results in a single response with the value of `next-page-token` set to `null` if the query parameter `pageToken` is not set in the request.
	// Servers that do not support pagination should ignore the `pageToken` parameter and return all results in a single response. The `next-page-token` must be omitted from the response.
	// Clients must interpret either `null` or missing response value of `next-page-token` as the end of the listing results.
	NextPageToken *PageToken `json:"next-page-token"`
}

// ListPoliciesResponse defines model for ListPoliciesResponse.
type ListPoliciesResponse struct {
	Identifiers *[]PolicyIdentifier `json:"identifiers,omitempty"`

	// NextPageToken An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter `pageToken` to the server.
	// Servers that support pagination should identify the `pageToken` parameter and return a `next-page-token` in the response if there are more results available.  After the initial request, the value of `next-page-token` from each response must be used as the `pageToken` parameter value for the next request. The server must return `null` value for the `next-page-token` in the last response.
	// Servers that support pagination must return all results in a single response with the value of `next-page-token` set to `null` if the query parameter `pageToken` is not set in the request.
	// Servers that do not support pagination should ignore the `pageToken` parameter and return all results in a single response. The `next-page-token` must be omitted from the response.
	// Clients must interpret either `null` or missing response value of `next-page-token` as the end of the listing results.
	NextPageToken *PageToken `json:"next-page-token"`
}

// ListTablesResponse defines model for ListTablesResponse.
type ListTablesResponse struct {
	Identifiers *[]TableIdentifier `json:"identifiers,omitempty"`

	// NextPageToken An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter `pageToken` to the server.
	// Servers that support pagination should identify the `pageToken` parameter and return a `next-page-token` in the response if there are more results available.  After the initial request, the value of `next-page-token` from each response must be used as the `pageToken` parameter value for the next request. The server must return `null` value for the `next-page-token` in the last response.
	// Servers that support pagination must return all results in a single response with the value of `next-page-token` set to `null` if the query parameter `pageToken` is not set in the request.
	// Servers that do not support pagination should ignore the `pageToken` parameter and return all results in a single response. The `next-page-token` must be omitted from the response.
	// Clients must interpret either `null` or missing response value of `next-page-token` as the end of the listing results.
	NextPageToken *PageToken `json:"next-page-token"`
}

// ListType defines model for ListType.
type ListType struct {
	Element         Type   `json:"element"`
	ElementId       int    `json:"element-id"`
	ElementRequired bool   `json:"element-required"`
	Type            string `json:"type"`
}

// LiteralExpression defines model for LiteralExpression.
type LiteralExpression struct {
	Term  Term                   `json:"term"`
	Type  ExpressionType         `json:"type"`
	Value map[string]interface{} `json:"value"`
}

// LoadCredentialsResponse defines model for LoadCredentialsResponse.
type LoadCredentialsResponse struct {
	StorageCredentials []StorageCredential `json:"storage-credentials"`
}

// LoadGenericTableResponse Result used when a table is successfully loaded.
type LoadGenericTableResponse struct {
	// Table Generic Table information.
	// - `name` (REQUIRED): name for the generic table
	// - `format` (REQUIRED): format for the generic table, i.e. "delta", "csv"
	// - `base-location` (OPTIONAL): table base location in URI format. For example: s3://<my-bucket>/path/to/table.
	//   - The table base location is a location that includes all files for the table.
	//   - A table with multiple disjoint locations (i.e. containing files that are outside the configured base location) is not compliant with the current generic table support in Polaris.
	//   - If no location is provided, clients or users are responsible for managing the location.
	//
	// - `properties` (OPTIONAL): properties for the generic table passed on creation
	// - `doc` (OPTIONAL): comment or description for the generic table
	Table GenericTable `json:"table"`
}

// LoadPolicyResponse defines model for LoadPolicyResponse.
type LoadPolicyResponse struct {
	// Policy A policy in Apache Polaris defines a set of rules for governing access, data usage, and operational consistency across various catalog resources.
	// Policies are stored within Polaris and can be attached to catalogs, namespaces, tables, or views.
	// For example, they can be used for fine-grained control over who can perform specific actions on certain resources.
	//
	// The policy object includes
	// - **policy-type:** The type of the policy, which determines the expected format and semantics of the policy content.
	// - **inheritable:** A boolean flag indicating whether the policy is inheritable.
	// - **name:**  A human-readable name for the policy, which must be unique within a given namespace.
	// - **description:** Detailed description of the purpose and functionalities of the policy.
	// - **content:** Policy content, which can be validated against predefined schemas of a policy type.
	// - **version:** Indicates the current version of the policy. Versions increased monotonically, the default value is 0
	//
	// Policies stored in Polaris serve as the persistent definition for access control and governance rules.
	Policy *Policy `json:"policy,omitempty"`
}

// LoadTableResult Result used when a table is successfully loaded.
//
// The table metadata JSON is returned in the `metadata` field. The corresponding file location of table metadata should be returned in the `metadata-location` field, unless the metadata is not yet committed. For example, a create transaction may return metadata that is staged but not committed.
// Clients can check whether metadata has changed by comparing metadata locations after the table has been created.
//
// The `config` map returns table-specific configuration for the table's resources, including its HTTP client and FileIO. For example, config may contain a specific FileIO implementation class for the table depending on its underlying storage.
//
// The following configurations should be respected by clients:
//
// ## General Configurations
//
// - `token`: Authorization bearer token to use for table requests if OAuth2 security is enabled
//
// ## AWS Configurations
//
// The following configurations should be respected when working with tables stored in AWS S3
//   - `client.region`: region to configure client for making requests to AWS
//   - `s3.access-key-id`: id for credentials that provide access to the data in S3
//   - `s3.secret-access-key`: secret for credentials that provide access to data in S3
//   - `s3.session-token`: if present, this value should be used for as the session token
//   - `s3.remote-signing-enabled`: if `true` remote signing should be performed as described in the `s3-signer-open-api.yaml` specification
//   - `s3.cross-region-access-enabled`: if `true`, S3 Cross-Region bucket access is enabled
//
// ## Storage Credentials
//
// Credentials for ADLS / GCS / S3 / ... are provided through the `storage-credentials` field.
// Clients must first check whether the respective credentials exist in the `storage-credentials` field before checking the `config` for credentials.
type LoadTableResult struct {
	Config   *map[string]string `json:"config,omitempty"`
	Metadata TableMetadata      `json:"metadata"`

	// MetadataLocation May be null if the table is staged as part of a transaction
	MetadataLocation   *string              `json:"metadata-location,omitempty"`
	StorageCredentials *[]StorageCredential `json:"storage-credentials,omitempty"`
}

// LoadViewResult Result used when a view is successfully loaded.
//
// The view metadata JSON is returned in the `metadata` field. The corresponding file location of view metadata is returned in the `metadata-location` field.
// Clients can check whether metadata has changed by comparing metadata locations after the view has been created.
//
// The `config` map returns view-specific configuration for the view's resources.
//
// The following configurations should be respected by clients:
//
// ## General Configurations
//
// - `token`: Authorization bearer token to use for view requests if OAuth2 security is enabled
type LoadViewResult struct {
	Config           *map[string]string `json:"config,omitempty"`
	Metadata         ViewMetadata       `json:"metadata"`
	MetadataLocation string             `json:"metadata-location"`
}

// LongTypeValue defines model for LongTypeValue.
type LongTypeValue = int64

// MapType defines model for MapType.
type MapType struct {
	Key           Type   `json:"key"`
	KeyId         int    `json:"key-id"`
	Type          string `json:"type"`
	Value         Type   `json:"value"`
	ValueId       int    `json:"value-id"`
	ValueRequired bool   `json:"value-required"`
}

// MetadataLog defines model for MetadataLog.
type MetadataLog = []struct {
	MetadataFile string `json:"metadata-file"`
	TimestampMs  int64  `json:"timestamp-ms"`
}

// MetricResult defines model for MetricResult.
type MetricResult struct {
	union json.RawMessage
}

// Metrics defines model for Metrics.
type Metrics map[string]MetricResult

// Namespace Reference to one or more levels of a namespace
type Namespace = []string

// NotExpression defines model for NotExpression.
type NotExpression struct {
	Child Expression     `json:"child"`
	Type  ExpressionType `json:"type"`
}

// NotificationRequest defines model for NotificationRequest.
type NotificationRequest struct {
	NotificationType NotificationType        `json:"notification-type"`
	Payload          TableUpdateNotification `json:"payload"`
}

// NotificationType defines model for NotificationType.
type NotificationType string

// NullOrder defines model for NullOrder.
type NullOrder string

// OAuthClientCredentialsRequest The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
//
// # OAuth2 client credentials request
//
// See https://datatracker.ietf.org/doc/html/rfc6749#section-4.4
type OAuthClientCredentialsRequest struct {
	// ClientId Client ID
	//
	// This can be sent in the request body, but OAuth2 recommends sending it in a Basic Authorization header.
	ClientId string `json:"client_id"`

	// ClientSecret Client secret
	//
	// This can be sent in the request body, but OAuth2 recommends sending it in a Basic Authorization header.
	ClientSecret string                                 `json:"client_secret"`
	GrantType    OAuthClientCredentialsRequestGrantType `json:"grant_type"`
	Scope        *string                                `json:"scope,omitempty"`
}

// OAuthClientCredentialsRequestGrantType defines model for OAuthClientCredentialsRequest.GrantType.
type OAuthClientCredentialsRequestGrantType string

// OAuthError The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
type OAuthError struct {
	Error            OAuthErrorError `json:"error"`
	ErrorDescription *string         `json:"error_description,omitempty"`
	ErrorUri         *string         `json:"error_uri,omitempty"`
}

// OAuthErrorError defines model for OAuthError.Error.
type OAuthErrorError string

// OAuthTokenExchangeRequest The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
//
// # OAuth2 token exchange request
//
// See https://datatracker.ietf.org/doc/html/rfc8693
type OAuthTokenExchangeRequest struct {
	// ActorToken Actor token for token exchange request
	ActorToken *string `json:"actor_token,omitempty"`

	// ActorTokenType Token type identifier, from RFC 8693 Section 3
	//
	// See https://datatracker.ietf.org/doc/html/rfc8693#section-3
	ActorTokenType *TokenType                         `json:"actor_token_type,omitempty"`
	GrantType      OAuthTokenExchangeRequestGrantType `json:"grant_type"`

	// RequestedTokenType Token type identifier, from RFC 8693 Section 3
	//
	// See https://datatracker.ietf.org/doc/html/rfc8693#section-3
	RequestedTokenType *TokenType `json:"requested_token_type,omitempty"`
	Scope              *string    `json:"scope,omitempty"`

	// SubjectToken Subject token for token exchange request
	SubjectToken string `json:"subject_token"`

	// SubjectTokenType Token type identifier, from RFC 8693 Section 3
	//
	// See https://datatracker.ietf.org/doc/html/rfc8693#section-3
	SubjectTokenType TokenType `json:"subject_token_type"`
}

// OAuthTokenExchangeRequestGrantType defines model for OAuthTokenExchangeRequest.GrantType.
type OAuthTokenExchangeRequestGrantType string

// OAuthTokenRequest The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
type OAuthTokenRequest struct {
	union json.RawMessage
}

// OAuthTokenResponse The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
type OAuthTokenResponse struct {
	// AccessToken The access token, for client credentials or token exchange
	AccessToken string `json:"access_token"`

	// ExpiresIn Lifetime of the access token in seconds for client credentials or token exchange
	ExpiresIn *int `json:"expires_in,omitempty"`

	// IssuedTokenType Token type identifier, from RFC 8693 Section 3
	//
	// See https://datatracker.ietf.org/doc/html/rfc8693#section-3
	IssuedTokenType *TokenType `json:"issued_token_type,omitempty"`

	// RefreshToken Refresh token for client credentials or token exchange
	RefreshToken *string `json:"refresh_token,omitempty"`

	// Scope Authorization scope for client credentials or token exchange
	Scope *string `json:"scope,omitempty"`

	// TokenType Access token type for client credentials or token exchange
	//
	// See https://datatracker.ietf.org/doc/html/rfc6749#section-7.1
	TokenType OAuthTokenResponseTokenType `json:"token_type"`
}

// OAuthTokenResponseTokenType Access token type for client credentials or token exchange
//
// See https://datatracker.ietf.org/doc/html/rfc6749#section-7.1
type OAuthTokenResponseTokenType string

// PageToken An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter `pageToken` to the server.
// Servers that support pagination should identify the `pageToken` parameter and return a `next-page-token` in the response if there are more results available.  After the initial request, the value of `next-page-token` from each response must be used as the `pageToken` parameter value for the next request. The server must return `null` value for the `next-page-token` in the last response.
// Servers that support pagination must return all results in a single response with the value of `next-page-token` set to `null` if the query parameter `pageToken` is not set in the request.
// Servers that do not support pagination should ignore the `pageToken` parameter and return all results in a single response. The `next-page-token` must be omitted from the response.
// Clients must interpret either `null` or missing response value of `next-page-token` as the end of the listing results.
type PageToken = string

// PartitionField defines model for PartitionField.
type PartitionField struct {
	FieldId   *int      `json:"field-id,omitempty"`
	Name      string    `json:"name"`
	SourceId  int       `json:"source-id"`
	Transform Transform `json:"transform"`
}

// PartitionSpec defines model for PartitionSpec.
type PartitionSpec struct {
	Fields []PartitionField `json:"fields"`
	SpecId *int             `json:"spec-id,omitempty"`
}

// PartitionStatisticsFile defines model for PartitionStatisticsFile.
type PartitionStatisticsFile struct {
	FileSizeInBytes int64  `json:"file-size-in-bytes"`
	SnapshotId      int64  `json:"snapshot-id"`
	StatisticsPath  string `json:"statistics-path"`
}

// Policy A policy in Apache Polaris defines a set of rules for governing access, data usage, and operational consistency across various catalog resources.
// Policies are stored within Polaris and can be attached to catalogs, namespaces, tables, or views.
// For example, they can be used for fine-grained control over who can perform specific actions on certain resources.
//
// The policy object includes
// - **policy-type:** The type of the policy, which determines the expected format and semantics of the policy content.
// - **inheritable:** A boolean flag indicating whether the policy is inheritable.
// - **name:**  A human-readable name for the policy, which must be unique within a given namespace.
// - **description:** Detailed description of the purpose and functionalities of the policy.
// - **content:** Policy content, which can be validated against predefined schemas of a policy type.
// - **version:** Indicates the current version of the policy. Versions increased monotonically, the default value is 0
//
// Policies stored in Polaris serve as the persistent definition for access control and governance rules.
type Policy struct {
	Content     *string `json:"content,omitempty"`
	Description *string `json:"description,omitempty"`
	Inheritable bool    `json:"inheritable"`

	// Name A policy name. A valid policy name should only consist of uppercase and lowercase letters (A-Z, a-z), digits (0-9), hyphens (-), underscores (_).
	Name       PolicyName `json:"name"`
	PolicyType string     `json:"policy-type"`
	Version    int        `json:"version"`
}

// PolicyAttachmentTarget defines model for PolicyAttachmentTarget.
type PolicyAttachmentTarget struct {
	// Path A list representing the hierarchical path to the target, ordered from the namespace level down to the entity.
	//
	// If the target is catalog, the path should be either empty or not set.
	Path *[]string `json:"path,omitempty"`

	// Type Policy can be attached to different levels:
	// 1. table-like: Policies specific to individual tables or views.
	// 2. namespace: Policies applies to a namespace.
	// 3. catalog: Policies that applies to a catalog
	Type PolicyAttachmentTargetType `json:"type"`
}

// PolicyAttachmentTargetType Policy can be attached to different levels:
// 1. table-like: Policies specific to individual tables or views.
// 2. namespace: Policies applies to a namespace.
// 3. catalog: Policies that applies to a catalog
type PolicyAttachmentTargetType string

// PolicyIdentifier defines model for PolicyIdentifier.
type PolicyIdentifier struct {
	Name string `json:"name"`

	// Namespace Reference to one or more levels of a namespace
	Namespace Namespace `json:"namespace"`
}

// PolicyName A policy name. A valid policy name should only consist of uppercase and lowercase letters (A-Z, a-z), digits (0-9), hyphens (-), underscores (_).
type PolicyName = string

// PolicyType The type of a policy
type PolicyType = string

// PrimitiveType defines model for PrimitiveType.
type PrimitiveType = string

// PrimitiveTypeValue defines model for PrimitiveTypeValue.
type PrimitiveTypeValue struct {
	union json.RawMessage
}

// Reference defines model for Reference.
type Reference = string

// RegisterTableRequest defines model for RegisterTableRequest.
type RegisterTableRequest struct {
	MetadataLocation string `json:"metadata-location"`
	Name             string `json:"name"`
}

// RemovePartitionSpecsUpdate defines model for RemovePartitionSpecsUpdate.
type RemovePartitionSpecsUpdate = BaseUpdate

// RemovePropertiesUpdate defines model for RemovePropertiesUpdate.
type RemovePropertiesUpdate = BaseUpdate

// RemoveSnapshotRefUpdate defines model for RemoveSnapshotRefUpdate.
type RemoveSnapshotRefUpdate = BaseUpdate

// RemoveSnapshotsUpdate defines model for RemoveSnapshotsUpdate.
type RemoveSnapshotsUpdate = BaseUpdate

// RemoveStatisticsUpdate defines model for RemoveStatisticsUpdate.
type RemoveStatisticsUpdate = BaseUpdate

// RenameTableRequest defines model for RenameTableRequest.
type RenameTableRequest struct {
	Destination TableIdentifier `json:"destination"`
	Source      TableIdentifier `json:"source"`
}

// ReportMetricsRequest defines model for ReportMetricsRequest.
type ReportMetricsRequest struct {
	ReportType string `json:"report-type"`
	union      json.RawMessage
}

// SQLViewRepresentation defines model for SQLViewRepresentation.
type SQLViewRepresentation struct {
	Dialect string `json:"dialect"`
	Sql     string `json:"sql"`
	Type    string `json:"type"`
}

// ScanReport defines model for ScanReport.
type ScanReport struct {
	Filter              Expression         `json:"filter"`
	Metadata            *map[string]string `json:"metadata,omitempty"`
	Metrics             Metrics            `json:"metrics"`
	ProjectedFieldIds   []int              `json:"projected-field-ids"`
	ProjectedFieldNames []string           `json:"projected-field-names"`
	SchemaId            int                `json:"schema-id"`
	SnapshotId          int64              `json:"snapshot-id"`
	TableName           string             `json:"table-name"`
}

// Schema defines model for Schema.
type Schema struct {
	Fields             []StructField `json:"fields"`
	IdentifierFieldIds *[]int        `json:"identifier-field-ids,omitempty"`
	SchemaId           *int          `json:"schema-id,omitempty"`
	Type               string        `json:"type"`
}

// SetCurrentSchemaUpdate defines model for SetCurrentSchemaUpdate.
type SetCurrentSchemaUpdate = BaseUpdate

// SetCurrentViewVersionUpdate defines model for SetCurrentViewVersionUpdate.
type SetCurrentViewVersionUpdate = BaseUpdate

// SetDefaultSortOrderUpdate defines model for SetDefaultSortOrderUpdate.
type SetDefaultSortOrderUpdate = BaseUpdate

// SetDefaultSpecUpdate defines model for SetDefaultSpecUpdate.
type SetDefaultSpecUpdate = BaseUpdate

// SetExpression defines model for SetExpression.
type SetExpression struct {
	Term   Term                     `json:"term"`
	Type   ExpressionType           `json:"type"`
	Values []map[string]interface{} `json:"values"`
}

// SetLocationUpdate defines model for SetLocationUpdate.
type SetLocationUpdate = BaseUpdate

// SetPropertiesUpdate defines model for SetPropertiesUpdate.
type SetPropertiesUpdate = BaseUpdate

// SetSnapshotRefUpdate defines model for SetSnapshotRefUpdate.
type SetSnapshotRefUpdate struct {
	Action             string                   `json:"action"`
	MaxRefAgeMs        *int64                   `json:"max-ref-age-ms,omitempty"`
	MaxSnapshotAgeMs   *int64                   `json:"max-snapshot-age-ms,omitempty"`
	MinSnapshotsToKeep *int                     `json:"min-snapshots-to-keep,omitempty"`
	SnapshotId         int64                    `json:"snapshot-id"`
	Type               SetSnapshotRefUpdateType `json:"type"`
}

// SetSnapshotRefUpdateType defines model for SetSnapshotRefUpdate.Type.
type SetSnapshotRefUpdateType string

// SetStatisticsUpdate defines model for SetStatisticsUpdate.
type SetStatisticsUpdate = BaseUpdate

// Snapshot defines model for Snapshot.
type Snapshot struct {
	// ManifestList Location of the snapshot's manifest list file
	ManifestList     string           `json:"manifest-list"`
	ParentSnapshotId *int64           `json:"parent-snapshot-id,omitempty"`
	SchemaId         *int             `json:"schema-id,omitempty"`
	SequenceNumber   *int64           `json:"sequence-number,omitempty"`
	SnapshotId       int64            `json:"snapshot-id"`
	Summary          Snapshot_Summary `json:"summary"`
	TimestampMs      int64            `json:"timestamp-ms"`
}

// SnapshotSummaryOperation defines model for Snapshot.Summary.Operation.
type SnapshotSummaryOperation string

// Snapshot_Summary defines model for Snapshot.Summary.
type Snapshot_Summary struct {
	Operation            SnapshotSummaryOperation `json:"operation"`
	AdditionalProperties map[string]string        `json:"-"`
}

// SnapshotLog defines model for SnapshotLog.
type SnapshotLog = []struct {
	SnapshotId  int64 `json:"snapshot-id"`
	TimestampMs int64 `json:"timestamp-ms"`
}

// SnapshotReference defines model for SnapshotReference.
type SnapshotReference struct {
	MaxRefAgeMs        *int64                `json:"max-ref-age-ms,omitempty"`
	MaxSnapshotAgeMs   *int64                `json:"max-snapshot-age-ms,omitempty"`
	MinSnapshotsToKeep *int                  `json:"min-snapshots-to-keep,omitempty"`
	SnapshotId         int64                 `json:"snapshot-id"`
	Type               SnapshotReferenceType `json:"type"`
}

// SnapshotReferenceType defines model for SnapshotReference.Type.
type SnapshotReferenceType string

// SnapshotReferences defines model for SnapshotReferences.
type SnapshotReferences map[string]SnapshotReference

// SortDirection defines model for SortDirection.
type SortDirection string

// SortField defines model for SortField.
type SortField struct {
	Direction SortDirection `json:"direction"`
	NullOrder NullOrder     `json:"null-order"`
	SourceId  int           `json:"source-id"`
	Transform Transform     `json:"transform"`
}

// SortOrder defines model for SortOrder.
type SortOrder struct {
	Fields  []SortField `json:"fields"`
	OrderId *int        `json:"order-id,omitempty"`
}

// StatisticsFile defines model for StatisticsFile.
type StatisticsFile struct {
	BlobMetadata          []BlobMetadata `json:"blob-metadata"`
	FileFooterSizeInBytes int64          `json:"file-footer-size-in-bytes"`
	FileSizeInBytes       int64          `json:"file-size-in-bytes"`
	SnapshotId            int64          `json:"snapshot-id"`
	StatisticsPath        string         `json:"statistics-path"`
}

// StorageCredential defines model for StorageCredential.
type StorageCredential struct {
	Config map[string]string `json:"config"`

	// Prefix Indicates a storage location prefix where the credential is relevant. Clients should choose the most specific prefix (by selecting the longest prefix) if several credentials of the same type are available.
	Prefix string `json:"prefix"`
}

// StringTypeValue defines model for StringTypeValue.
type StringTypeValue = string

// StructField defines model for StructField.
type StructField struct {
	Doc            *string             `json:"doc,omitempty"`
	Id             int                 `json:"id"`
	InitialDefault *PrimitiveTypeValue `json:"initial-default,omitempty"`
	Name           string              `json:"name"`
	Required       bool                `json:"required"`
	Type           Type                `json:"type"`
	WriteDefault   *PrimitiveTypeValue `json:"write-default,omitempty"`
}

// StructType defines model for StructType.
type StructType struct {
	Fields []StructField `json:"fields"`
	Type   string        `json:"type"`
}

// TableIdentifier defines model for TableIdentifier.
type TableIdentifier struct {
	Name string `json:"name"`

	// Namespace Reference to one or more levels of a namespace
	Namespace Namespace `json:"namespace"`
}

// TableMetadata defines model for TableMetadata.
type TableMetadata struct {
	CurrentSchemaId     *int                       `json:"current-schema-id,omitempty"`
	CurrentSnapshotId   *int64                     `json:"current-snapshot-id,omitempty"`
	DefaultSortOrderId  *int                       `json:"default-sort-order-id,omitempty"`
	DefaultSpecId       *int                       `json:"default-spec-id,omitempty"`
	FormatVersion       int                        `json:"format-version"`
	LastColumnId        *int                       `json:"last-column-id,omitempty"`
	LastPartitionId     *int                       `json:"last-partition-id,omitempty"`
	LastSequenceNumber  *int64                     `json:"last-sequence-number,omitempty"`
	LastUpdatedMs       *int64                     `json:"last-updated-ms,omitempty"`
	Location            *string                    `json:"location,omitempty"`
	MetadataLog         *MetadataLog               `json:"metadata-log,omitempty"`
	PartitionSpecs      *[]PartitionSpec           `json:"partition-specs,omitempty"`
	PartitionStatistics *[]PartitionStatisticsFile `json:"partition-statistics,omitempty"`
	Properties          *map[string]string         `json:"properties,omitempty"`
	Refs                *SnapshotReferences        `json:"refs,omitempty"`
	Schemas             *[]Schema                  `json:"schemas,omitempty"`
	SnapshotLog         *SnapshotLog               `json:"snapshot-log,omitempty"`
	Snapshots           *[]Snapshot                `json:"snapshots,omitempty"`
	SortOrders          *[]SortOrder               `json:"sort-orders,omitempty"`
	Statistics          *[]StatisticsFile          `json:"statistics,omitempty"`
	TableUuid           string                     `json:"table-uuid"`
}

// TableRequirement defines model for TableRequirement.
type TableRequirement struct {
	Type string `json:"type"`
}

// TableUpdate defines model for TableUpdate.
type TableUpdate struct {
	union json.RawMessage
}

// TableUpdateNotification defines model for TableUpdateNotification.
type TableUpdateNotification struct {
	Metadata         *TableMetadata `json:"metadata,omitempty"`
	MetadataLocation string         `json:"metadata-location"`
	TableName        string         `json:"table-name"`
	TableUuid        string         `json:"table-uuid"`
	Timestamp        int64          `json:"timestamp"`
}

// Term defines model for Term.
type Term struct {
	union json.RawMessage
}

// TimeTypeValue Time type values follow the 'HH:MM:SS.ssssss' ISO-8601 format with microsecond precision
type TimeTypeValue = string

// TimerResult defines model for TimerResult.
type TimerResult struct {
	Count         int64  `json:"count"`
	TimeUnit      string `json:"time-unit"`
	TotalDuration int64  `json:"total-duration"`
}

// TimestampNanoTypeValue Timestamp_ns type values follow the 'YYYY-MM-DDTHH:MM:SS.sssssssss' ISO-8601 format with nanosecond precision
type TimestampNanoTypeValue = string

// TimestampTypeValue Timestamp type values follow the 'YYYY-MM-DDTHH:MM:SS.ssssss' ISO-8601 format with microsecond precision
type TimestampTypeValue = string

// TimestampTzNanoTypeValue Timestamp_ns type values follow the 'YYYY-MM-DDTHH:MM:SS.sssssssss+00:00' ISO-8601 format with nanosecond  precision, and a timezone offset (+00:00 for UTC)
type TimestampTzNanoTypeValue = string

// TimestampTzTypeValue TimestampTz type values follow the 'YYYY-MM-DDTHH:MM:SS.ssssss+00:00' ISO-8601 format with microsecond precision,  and a timezone offset (+00:00 for UTC)
type TimestampTzTypeValue = string

// TokenType Token type identifier, from RFC 8693 Section 3
//
// See https://datatracker.ietf.org/doc/html/rfc8693#section-3
type TokenType string

// Transform defines model for Transform.
type Transform = string

// TransformTerm defines model for TransformTerm.
type TransformTerm struct {
	Term      Reference `json:"term"`
	Transform Transform `json:"transform"`
	Type      string    `json:"type"`
}

// TrueExpression defines model for TrueExpression.
type TrueExpression struct {
	Type ExpressionType `json:"type"`
}

// Type defines model for Type.
type Type struct {
	union json.RawMessage
}

// UUIDTypeValue UUID type values are serialized as a 36-character lowercase string in standard UUID format as specified  by RFC-4122
type UUIDTypeValue = openapi_types.UUID

// UnaryExpression defines model for UnaryExpression.
type UnaryExpression struct {
	Term  Term                   `json:"term"`
	Type  ExpressionType         `json:"type"`
	Value map[string]interface{} `json:"value"`
}

// UpdateNamespacePropertiesRequest defines model for UpdateNamespacePropertiesRequest.
type UpdateNamespacePropertiesRequest struct {
	Removals *[]string          `json:"removals,omitempty"`
	Updates  *map[string]string `json:"updates,omitempty"`
}

// UpdateNamespacePropertiesResponse defines model for UpdateNamespacePropertiesResponse.
type UpdateNamespacePropertiesResponse struct {
	// Missing List of properties requested for removal that were not found in the namespace's properties. Represents a partial success response. Server's do not need to implement this.
	Missing *[]string `json:"missing"`

	// Removed List of properties that were removed
	Removed []string `json:"removed"`

	// Updated List of property keys that were added or updated
	Updated []string `json:"updated"`
}

// UpdatePolicyRequest defines model for UpdatePolicyRequest.
type UpdatePolicyRequest struct {
	Content              *string `json:"content,omitempty"`
	CurrentPolicyVersion *int    `json:"current-policy-version,omitempty"`
	Description          *string `json:"description,omitempty"`
}

// UpgradeFormatVersionUpdate defines model for UpgradeFormatVersionUpdate.
type UpgradeFormatVersionUpdate = BaseUpdate

// ViewHistoryEntry defines model for ViewHistoryEntry.
type ViewHistoryEntry struct {
	TimestampMs int64 `json:"timestamp-ms"`
	VersionId   int   `json:"version-id"`
}

// ViewMetadata defines model for ViewMetadata.
type ViewMetadata struct {
	CurrentVersionId int                `json:"current-version-id"`
	FormatVersion    int                `json:"format-version"`
	Location         string             `json:"location"`
	Properties       *map[string]string `json:"properties,omitempty"`
	Schemas          []Schema           `json:"schemas"`
	VersionLog       []ViewHistoryEntry `json:"version-log"`
	Versions         []ViewVersion      `json:"versions"`
	ViewUuid         string             `json:"view-uuid"`
}

// ViewRepresentation defines model for ViewRepresentation.
type ViewRepresentation struct {
	union json.RawMessage
}

// ViewRequirement defines model for ViewRequirement.
type ViewRequirement struct {
	union json.RawMessage
}

// ViewUpdate defines model for ViewUpdate.
type ViewUpdate struct {
	union json.RawMessage
}

// ViewVersion defines model for ViewVersion.
type ViewVersion struct {
	DefaultCatalog *string `json:"default-catalog,omitempty"`

	// DefaultNamespace Reference to one or more levels of a namespace
	DefaultNamespace Namespace            `json:"default-namespace"`
	Representations  []ViewRepresentation `json:"representations"`

	// SchemaId Schema ID to set as current, or -1 to set last added schema
	SchemaId    int               `json:"schema-id"`
	Summary     map[string]string `json:"summary"`
	TimestampMs int64             `json:"timestamp-ms"`
	VersionId   int               `json:"version-id"`
}

// DataAccess defines model for data-access.
type DataAccess string

// GenericTableName defines model for generic-table.
type GenericTableName = string

// NamespaceString defines model for namespace.
type NamespaceString = string

// PageSize defines model for page-size.
type PageSize = int

// Prefix defines model for prefix.
type Prefix = string

// Table defines model for table.
type Table = string

// View defines model for view.
type View = string

// AuthenticationTimeoutResponse JSON wrapper for all error responses (non-2xx)
type AuthenticationTimeoutResponse = IcebergErrorResponse

// BadRequestErrorResponse JSON wrapper for all error responses (non-2xx)
type BadRequestErrorResponse = IcebergErrorResponse

// CreateGenericTableResponse Result used when a table is successfully loaded.
type CreateGenericTableResponse = LoadGenericTableResponse

// CreatePolicyResponse defines model for CreatePolicyResponse.
type CreatePolicyResponse = LoadPolicyResponse

// CreateTableResponse Result used when a table is successfully loaded.
//
// The table metadata JSON is returned in the `metadata` field. The corresponding file location of table metadata should be returned in the `metadata-location` field, unless the metadata is not yet committed. For example, a create transaction may return metadata that is staged but not committed.
// Clients can check whether metadata has changed by comparing metadata locations after the table has been created.
//
// The `config` map returns table-specific configuration for the table's resources, including its HTTP client and FileIO. For example, config may contain a specific FileIO implementation class for the table depending on its underlying storage.
//
// The following configurations should be respected by clients:
//
// ## General Configurations
//
// - `token`: Authorization bearer token to use for table requests if OAuth2 security is enabled
//
// ## AWS Configurations
//
// The following configurations should be respected when working with tables stored in AWS S3
//   - `client.region`: region to configure client for making requests to AWS
//   - `s3.access-key-id`: id for credentials that provide access to the data in S3
//   - `s3.secret-access-key`: secret for credentials that provide access to data in S3
//   - `s3.session-token`: if present, this value should be used for as the session token
//   - `s3.remote-signing-enabled`: if `true` remote signing should be performed as described in the `s3-signer-open-api.yaml` specification
//   - `s3.cross-region-access-enabled`: if `true`, S3 Cross-Region bucket access is enabled
//
// ## Storage Credentials
//
// Credentials for ADLS / GCS / S3 / ... are provided through the `storage-credentials` field.
// Clients must first check whether the respective credentials exist in the `storage-credentials` field before checking the `config` for credentials.
type CreateTableResponse = LoadTableResult

// ForbiddenResponse JSON wrapper for all error responses (non-2xx)
type ForbiddenResponse = IcebergErrorResponse

// LoadTableResponse Result used when a table is successfully loaded.
//
// The table metadata JSON is returned in the `metadata` field. The corresponding file location of table metadata should be returned in the `metadata-location` field, unless the metadata is not yet committed. For example, a create transaction may return metadata that is staged but not committed.
// Clients can check whether metadata has changed by comparing metadata locations after the table has been created.
//
// The `config` map returns table-specific configuration for the table's resources, including its HTTP client and FileIO. For example, config may contain a specific FileIO implementation class for the table depending on its underlying storage.
//
// The following configurations should be respected by clients:
//
// ## General Configurations
//
// - `token`: Authorization bearer token to use for table requests if OAuth2 security is enabled
//
// ## AWS Configurations
//
// The following configurations should be respected when working with tables stored in AWS S3
//   - `client.region`: region to configure client for making requests to AWS
//   - `s3.access-key-id`: id for credentials that provide access to the data in S3
//   - `s3.secret-access-key`: secret for credentials that provide access to data in S3
//   - `s3.session-token`: if present, this value should be used for as the session token
//   - `s3.remote-signing-enabled`: if `true` remote signing should be performed as described in the `s3-signer-open-api.yaml` specification
//   - `s3.cross-region-access-enabled`: if `true`, S3 Cross-Region bucket access is enabled
//
// ## Storage Credentials
//
// Credentials for ADLS / GCS / S3 / ... are provided through the `storage-credentials` field.
// Clients must first check whether the respective credentials exist in the `storage-credentials` field before checking the `config` for credentials.
type LoadTableResponse = LoadTableResult

// LoadViewResponse Result used when a view is successfully loaded.
//
// The view metadata JSON is returned in the `metadata` field. The corresponding file location of view metadata is returned in the `metadata-location` field.
// Clients can check whether metadata has changed by comparing metadata locations after the view has been created.
//
// The `config` map returns view-specific configuration for the view's resources.
//
// The following configurations should be respected by clients:
//
// ## General Configurations
//
// - `token`: Authorization bearer token to use for view requests if OAuth2 security is enabled
type LoadViewResponse = LoadViewResult

// OAuthErrorResponse The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
type OAuthErrorResponse = OAuthError

// ServerErrorResponse JSON wrapper for all error responses (non-2xx)
type ServerErrorResponse = IcebergErrorResponse

// ServiceUnavailableResponse JSON wrapper for all error responses (non-2xx)
type ServiceUnavailableResponse = IcebergErrorResponse

// UnauthorizedResponse JSON wrapper for all error responses (non-2xx)
type UnauthorizedResponse = IcebergErrorResponse

// UnsupportedOperationResponse JSON error payload returned in a response with further details on the error
type UnsupportedOperationResponse = ErrorModel

// UpdatePolicyResponse defines model for UpdatePolicyResponse.
type UpdatePolicyResponse = LoadPolicyResponse

// GetApplicablePoliciesParams defines parameters for GetApplicablePolicies.
type GetApplicablePoliciesParams struct {
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// PageSize For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Namespace A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
	Namespace *string `form:"namespace,omitempty" json:"namespace,omitempty"`

	// TargetName Name of the target table/view
	TargetName *string     `form:"target-name,omitempty" json:"target-name,omitempty"`
	PolicyType *PolicyType `form:"policyType,omitempty" json:"policyType,omitempty"`
}

// ListGenericTablesParams defines parameters for ListGenericTables.
type ListGenericTablesParams struct {
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// PageSize For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// PageSize For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
	PageSize   *PageSize   `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	PolicyType *PolicyType `form:"policyType,omitempty" json:"policyType,omitempty"`
}

// DropPolicyParams defines parameters for DropPolicy.
type DropPolicyParams struct {
	// DetachAll When set to true, the dropPolicy operation will also delete all mappings between the policy and its attached target entities.
	DetachAll *bool `form:"detach-all,omitempty" json:"detach-all,omitempty"`
}

// GetConfigParams defines parameters for GetConfig.
type GetConfigParams struct {
	// Warehouse Warehouse location or identifier to request from the service
	Warehouse *string `form:"warehouse,omitempty" json:"warehouse,omitempty"`
}

// GetTokenParams defines parameters for GetToken.
type GetTokenParams struct {
	Authorization *string `json:"Authorization,omitempty"`
}

// ListNamespacesParams defines parameters for ListNamespaces.
type ListNamespacesParams struct {
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// PageSize For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Parent An optional namespace, underneath which to list namespaces. If not provided or empty, all top-level namespaces should be listed. If parent is a multipart namespace, the parts must be separated by the unit separator (`0x1F`) byte.
	Parent *string `form:"parent,omitempty" json:"parent,omitempty"`
}

// ListTablesParams defines parameters for ListTables.
type ListTablesParams struct {
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// PageSize For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// CreateTableParams defines parameters for CreateTable.
type CreateTableParams struct {
	// XIcebergAccessDelegation Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.
	//
	// Specific properties and handling for `vended-credentials` is documented in the `LoadTableResult` schema section of this spec document.
	//
	// The protocol and specification for `remote-signing` is documented in  the `s3-signer-open-api.yaml` OpenApi spec in the `aws` module.
	XIcebergAccessDelegation *CreateTableParamsXIcebergAccessDelegation `json:"X-Iceberg-Access-Delegation,omitempty"`
}

// CreateTableParamsXIcebergAccessDelegation defines parameters for CreateTable.
type CreateTableParamsXIcebergAccessDelegation string

// DropTableParams defines parameters for DropTable.
type DropTableParams struct {
	// PurgeRequested Whether the user requested to purge the underlying table's data and metadata
	PurgeRequested *bool `form:"purgeRequested,omitempty" json:"purgeRequested,omitempty"`
}

// LoadTableParams defines parameters for LoadTable.
type LoadTableParams struct {
	// Snapshots The snapshots to return in the body of the metadata. Setting the value to `all` would return the full set of snapshots currently valid for the table. Setting the value to `refs` would load all snapshots referenced by branches or tags.
	// Default if no param is provided is `all`.
	Snapshots *LoadTableParamsSnapshots `form:"snapshots,omitempty" json:"snapshots,omitempty"`

	// XIcebergAccessDelegation Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.
	//
	// Specific properties and handling for `vended-credentials` is documented in the `LoadTableResult` schema section of this spec document.
	//
	// The protocol and specification for `remote-signing` is documented in  the `s3-signer-open-api.yaml` OpenApi spec in the `aws` module.
	XIcebergAccessDelegation *LoadTableParamsXIcebergAccessDelegation `json:"X-Iceberg-Access-Delegation,omitempty"`

	// IfNoneMatch An optional header that allows the server to return 304 (Not Modified) if the metadata is current. The content is the value of the ETag received in a CreateTableResponse or LoadTableResponse.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// LoadTableParamsSnapshots defines parameters for LoadTable.
type LoadTableParamsSnapshots string

// LoadTableParamsXIcebergAccessDelegation defines parameters for LoadTable.
type LoadTableParamsXIcebergAccessDelegation string

// ListViewsParams defines parameters for ListViews.
type ListViewsParams struct {
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// PageSize For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// CreateGenericTableJSONRequestBody defines body for CreateGenericTable for application/json ContentType.
type CreateGenericTableJSONRequestBody = CreateGenericTableRequest

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody = CreatePolicyRequest

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody = UpdatePolicyRequest

// DetachPolicyJSONRequestBody defines body for DetachPolicy for application/json ContentType.
type DetachPolicyJSONRequestBody = DetachPolicyRequest

// AttachPolicyJSONRequestBody defines body for AttachPolicy for application/json ContentType.
type AttachPolicyJSONRequestBody = AttachPolicyRequest

// GetTokenFormdataRequestBody defines body for GetToken for application/x-www-form-urlencoded ContentType.
type GetTokenFormdataRequestBody = OAuthTokenRequest

// CreateNamespaceJSONRequestBody defines body for CreateNamespace for application/json ContentType.
type CreateNamespaceJSONRequestBody = CreateNamespaceRequest

// UpdatePropertiesJSONRequestBody defines body for UpdateProperties for application/json ContentType.
type UpdatePropertiesJSONRequestBody = UpdateNamespacePropertiesRequest

// RegisterTableJSONRequestBody defines body for RegisterTable for application/json ContentType.
type RegisterTableJSONRequestBody = RegisterTableRequest

// CreateTableJSONRequestBody defines body for CreateTable for application/json ContentType.
type CreateTableJSONRequestBody = CreateTableRequest

// UpdateTableJSONRequestBody defines body for UpdateTable for application/json ContentType.
type UpdateTableJSONRequestBody = CommitTableRequest

// ReportMetricsJSONRequestBody defines body for ReportMetrics for application/json ContentType.
type ReportMetricsJSONRequestBody = ReportMetricsRequest

// SendNotificationJSONRequestBody defines body for SendNotification for application/json ContentType.
type SendNotificationJSONRequestBody = NotificationRequest

// CreateViewJSONRequestBody defines body for CreateView for application/json ContentType.
type CreateViewJSONRequestBody = CreateViewRequest

// ReplaceViewJSONRequestBody defines body for ReplaceView for application/json ContentType.
type ReplaceViewJSONRequestBody = CommitViewRequest

// RenameTableJSONRequestBody defines body for RenameTable for application/json ContentType.
type RenameTableJSONRequestBody = RenameTableRequest

// CommitTransactionJSONRequestBody defines body for CommitTransaction for application/json ContentType.
type CommitTransactionJSONRequestBody = CommitTransactionRequest

// RenameViewJSONRequestBody defines body for RenameView for application/json ContentType.
type RenameViewJSONRequestBody = RenameTableRequest

// Getter for additional properties for Snapshot_Summary. Returns the specified
// element and whether it was found
func (a Snapshot_Summary) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Snapshot_Summary
func (a *Snapshot_Summary) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Snapshot_Summary to handle AdditionalProperties
func (a *Snapshot_Summary) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["operation"]; found {
		err = json.Unmarshal(raw, &a.Operation)
		if err != nil {
			return fmt.Errorf("error reading 'operation': %w", err)
		}
		delete(object, "operation")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Snapshot_Summary to handle AdditionalProperties
func (a Snapshot_Summary) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["operation"], err = json.Marshal(a.Operation)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'operation': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsTrueExpression returns the union data inside the Expression as a TrueExpression
func (t Expression) AsTrueExpression() (TrueExpression, error) {
	var body TrueExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrueExpression overwrites any union data inside the Expression as the provided TrueExpression
func (t *Expression) FromTrueExpression(v TrueExpression) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrueExpression performs a merge with any union data inside the Expression, using the provided TrueExpression
func (t *Expression) MergeTrueExpression(v TrueExpression) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFalseExpression returns the union data inside the Expression as a FalseExpression
func (t Expression) AsFalseExpression() (FalseExpression, error) {
	var body FalseExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFalseExpression overwrites any union data inside the Expression as the provided FalseExpression
func (t *Expression) FromFalseExpression(v FalseExpression) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFalseExpression performs a merge with any union data inside the Expression, using the provided FalseExpression
func (t *Expression) MergeFalseExpression(v FalseExpression) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAndOrExpression returns the union data inside the Expression as a AndOrExpression
func (t Expression) AsAndOrExpression() (AndOrExpression, error) {
	var body AndOrExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAndOrExpression overwrites any union data inside the Expression as the provided AndOrExpression
func (t *Expression) FromAndOrExpression(v AndOrExpression) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAndOrExpression performs a merge with any union data inside the Expression, using the provided AndOrExpression
func (t *Expression) MergeAndOrExpression(v AndOrExpression) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotExpression returns the union data inside the Expression as a NotExpression
func (t Expression) AsNotExpression() (NotExpression, error) {
	var body NotExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotExpression overwrites any union data inside the Expression as the provided NotExpression
func (t *Expression) FromNotExpression(v NotExpression) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotExpression performs a merge with any union data inside the Expression, using the provided NotExpression
func (t *Expression) MergeNotExpression(v NotExpression) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetExpression returns the union data inside the Expression as a SetExpression
func (t Expression) AsSetExpression() (SetExpression, error) {
	var body SetExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetExpression overwrites any union data inside the Expression as the provided SetExpression
func (t *Expression) FromSetExpression(v SetExpression) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetExpression performs a merge with any union data inside the Expression, using the provided SetExpression
func (t *Expression) MergeSetExpression(v SetExpression) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLiteralExpression returns the union data inside the Expression as a LiteralExpression
func (t Expression) AsLiteralExpression() (LiteralExpression, error) {
	var body LiteralExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLiteralExpression overwrites any union data inside the Expression as the provided LiteralExpression
func (t *Expression) FromLiteralExpression(v LiteralExpression) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLiteralExpression performs a merge with any union data inside the Expression, using the provided LiteralExpression
func (t *Expression) MergeLiteralExpression(v LiteralExpression) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnaryExpression returns the union data inside the Expression as a UnaryExpression
func (t Expression) AsUnaryExpression() (UnaryExpression, error) {
	var body UnaryExpression
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnaryExpression overwrites any union data inside the Expression as the provided UnaryExpression
func (t *Expression) FromUnaryExpression(v UnaryExpression) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnaryExpression performs a merge with any union data inside the Expression, using the provided UnaryExpression
func (t *Expression) MergeUnaryExpression(v UnaryExpression) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Expression) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Expression) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCounterResult returns the union data inside the MetricResult as a CounterResult
func (t MetricResult) AsCounterResult() (CounterResult, error) {
	var body CounterResult
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCounterResult overwrites any union data inside the MetricResult as the provided CounterResult
func (t *MetricResult) FromCounterResult(v CounterResult) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCounterResult performs a merge with any union data inside the MetricResult, using the provided CounterResult
func (t *MetricResult) MergeCounterResult(v CounterResult) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimerResult returns the union data inside the MetricResult as a TimerResult
func (t MetricResult) AsTimerResult() (TimerResult, error) {
	var body TimerResult
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimerResult overwrites any union data inside the MetricResult as the provided TimerResult
func (t *MetricResult) FromTimerResult(v TimerResult) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimerResult performs a merge with any union data inside the MetricResult, using the provided TimerResult
func (t *MetricResult) MergeTimerResult(v TimerResult) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MetricResult) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MetricResult) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOAuthClientCredentialsRequest returns the union data inside the OAuthTokenRequest as a OAuthClientCredentialsRequest
func (t OAuthTokenRequest) AsOAuthClientCredentialsRequest() (OAuthClientCredentialsRequest, error) {
	var body OAuthClientCredentialsRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOAuthClientCredentialsRequest overwrites any union data inside the OAuthTokenRequest as the provided OAuthClientCredentialsRequest
func (t *OAuthTokenRequest) FromOAuthClientCredentialsRequest(v OAuthClientCredentialsRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOAuthClientCredentialsRequest performs a merge with any union data inside the OAuthTokenRequest, using the provided OAuthClientCredentialsRequest
func (t *OAuthTokenRequest) MergeOAuthClientCredentialsRequest(v OAuthClientCredentialsRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOAuthTokenExchangeRequest returns the union data inside the OAuthTokenRequest as a OAuthTokenExchangeRequest
func (t OAuthTokenRequest) AsOAuthTokenExchangeRequest() (OAuthTokenExchangeRequest, error) {
	var body OAuthTokenExchangeRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOAuthTokenExchangeRequest overwrites any union data inside the OAuthTokenRequest as the provided OAuthTokenExchangeRequest
func (t *OAuthTokenRequest) FromOAuthTokenExchangeRequest(v OAuthTokenExchangeRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOAuthTokenExchangeRequest performs a merge with any union data inside the OAuthTokenRequest, using the provided OAuthTokenExchangeRequest
func (t *OAuthTokenRequest) MergeOAuthTokenExchangeRequest(v OAuthTokenExchangeRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OAuthTokenRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OAuthTokenRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBooleanTypeValue returns the union data inside the PrimitiveTypeValue as a BooleanTypeValue
func (t PrimitiveTypeValue) AsBooleanTypeValue() (BooleanTypeValue, error) {
	var body BooleanTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided BooleanTypeValue
func (t *PrimitiveTypeValue) FromBooleanTypeValue(v BooleanTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided BooleanTypeValue
func (t *PrimitiveTypeValue) MergeBooleanTypeValue(v BooleanTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerTypeValue returns the union data inside the PrimitiveTypeValue as a IntegerTypeValue
func (t PrimitiveTypeValue) AsIntegerTypeValue() (IntegerTypeValue, error) {
	var body IntegerTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided IntegerTypeValue
func (t *PrimitiveTypeValue) FromIntegerTypeValue(v IntegerTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided IntegerTypeValue
func (t *PrimitiveTypeValue) MergeIntegerTypeValue(v IntegerTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLongTypeValue returns the union data inside the PrimitiveTypeValue as a LongTypeValue
func (t PrimitiveTypeValue) AsLongTypeValue() (LongTypeValue, error) {
	var body LongTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLongTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided LongTypeValue
func (t *PrimitiveTypeValue) FromLongTypeValue(v LongTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLongTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided LongTypeValue
func (t *PrimitiveTypeValue) MergeLongTypeValue(v LongTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatTypeValue returns the union data inside the PrimitiveTypeValue as a FloatTypeValue
func (t PrimitiveTypeValue) AsFloatTypeValue() (FloatTypeValue, error) {
	var body FloatTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided FloatTypeValue
func (t *PrimitiveTypeValue) FromFloatTypeValue(v FloatTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided FloatTypeValue
func (t *PrimitiveTypeValue) MergeFloatTypeValue(v FloatTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDoubleTypeValue returns the union data inside the PrimitiveTypeValue as a DoubleTypeValue
func (t PrimitiveTypeValue) AsDoubleTypeValue() (DoubleTypeValue, error) {
	var body DoubleTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDoubleTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided DoubleTypeValue
func (t *PrimitiveTypeValue) FromDoubleTypeValue(v DoubleTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDoubleTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided DoubleTypeValue
func (t *PrimitiveTypeValue) MergeDoubleTypeValue(v DoubleTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDecimalTypeValue returns the union data inside the PrimitiveTypeValue as a DecimalTypeValue
func (t PrimitiveTypeValue) AsDecimalTypeValue() (DecimalTypeValue, error) {
	var body DecimalTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDecimalTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided DecimalTypeValue
func (t *PrimitiveTypeValue) FromDecimalTypeValue(v DecimalTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDecimalTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided DecimalTypeValue
func (t *PrimitiveTypeValue) MergeDecimalTypeValue(v DecimalTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStringTypeValue returns the union data inside the PrimitiveTypeValue as a StringTypeValue
func (t PrimitiveTypeValue) AsStringTypeValue() (StringTypeValue, error) {
	var body StringTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided StringTypeValue
func (t *PrimitiveTypeValue) FromStringTypeValue(v StringTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided StringTypeValue
func (t *PrimitiveTypeValue) MergeStringTypeValue(v StringTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUUIDTypeValue returns the union data inside the PrimitiveTypeValue as a UUIDTypeValue
func (t PrimitiveTypeValue) AsUUIDTypeValue() (UUIDTypeValue, error) {
	var body UUIDTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUUIDTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided UUIDTypeValue
func (t *PrimitiveTypeValue) FromUUIDTypeValue(v UUIDTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUUIDTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided UUIDTypeValue
func (t *PrimitiveTypeValue) MergeUUIDTypeValue(v UUIDTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDateTypeValue returns the union data inside the PrimitiveTypeValue as a DateTypeValue
func (t PrimitiveTypeValue) AsDateTypeValue() (DateTypeValue, error) {
	var body DateTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided DateTypeValue
func (t *PrimitiveTypeValue) FromDateTypeValue(v DateTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided DateTypeValue
func (t *PrimitiveTypeValue) MergeDateTypeValue(v DateTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimeTypeValue returns the union data inside the PrimitiveTypeValue as a TimeTypeValue
func (t PrimitiveTypeValue) AsTimeTypeValue() (TimeTypeValue, error) {
	var body TimeTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimeTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided TimeTypeValue
func (t *PrimitiveTypeValue) FromTimeTypeValue(v TimeTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimeTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided TimeTypeValue
func (t *PrimitiveTypeValue) MergeTimeTypeValue(v TimeTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimestampTypeValue returns the union data inside the PrimitiveTypeValue as a TimestampTypeValue
func (t PrimitiveTypeValue) AsTimestampTypeValue() (TimestampTypeValue, error) {
	var body TimestampTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimestampTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided TimestampTypeValue
func (t *PrimitiveTypeValue) FromTimestampTypeValue(v TimestampTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimestampTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided TimestampTypeValue
func (t *PrimitiveTypeValue) MergeTimestampTypeValue(v TimestampTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimestampTzTypeValue returns the union data inside the PrimitiveTypeValue as a TimestampTzTypeValue
func (t PrimitiveTypeValue) AsTimestampTzTypeValue() (TimestampTzTypeValue, error) {
	var body TimestampTzTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimestampTzTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided TimestampTzTypeValue
func (t *PrimitiveTypeValue) FromTimestampTzTypeValue(v TimestampTzTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimestampTzTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided TimestampTzTypeValue
func (t *PrimitiveTypeValue) MergeTimestampTzTypeValue(v TimestampTzTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimestampNanoTypeValue returns the union data inside the PrimitiveTypeValue as a TimestampNanoTypeValue
func (t PrimitiveTypeValue) AsTimestampNanoTypeValue() (TimestampNanoTypeValue, error) {
	var body TimestampNanoTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimestampNanoTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided TimestampNanoTypeValue
func (t *PrimitiveTypeValue) FromTimestampNanoTypeValue(v TimestampNanoTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimestampNanoTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided TimestampNanoTypeValue
func (t *PrimitiveTypeValue) MergeTimestampNanoTypeValue(v TimestampNanoTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimestampTzNanoTypeValue returns the union data inside the PrimitiveTypeValue as a TimestampTzNanoTypeValue
func (t PrimitiveTypeValue) AsTimestampTzNanoTypeValue() (TimestampTzNanoTypeValue, error) {
	var body TimestampTzNanoTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimestampTzNanoTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided TimestampTzNanoTypeValue
func (t *PrimitiveTypeValue) FromTimestampTzNanoTypeValue(v TimestampTzNanoTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimestampTzNanoTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided TimestampTzNanoTypeValue
func (t *PrimitiveTypeValue) MergeTimestampTzNanoTypeValue(v TimestampTzNanoTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFixedTypeValue returns the union data inside the PrimitiveTypeValue as a FixedTypeValue
func (t PrimitiveTypeValue) AsFixedTypeValue() (FixedTypeValue, error) {
	var body FixedTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFixedTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided FixedTypeValue
func (t *PrimitiveTypeValue) FromFixedTypeValue(v FixedTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFixedTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided FixedTypeValue
func (t *PrimitiveTypeValue) MergeFixedTypeValue(v FixedTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBinaryTypeValue returns the union data inside the PrimitiveTypeValue as a BinaryTypeValue
func (t PrimitiveTypeValue) AsBinaryTypeValue() (BinaryTypeValue, error) {
	var body BinaryTypeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBinaryTypeValue overwrites any union data inside the PrimitiveTypeValue as the provided BinaryTypeValue
func (t *PrimitiveTypeValue) FromBinaryTypeValue(v BinaryTypeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBinaryTypeValue performs a merge with any union data inside the PrimitiveTypeValue, using the provided BinaryTypeValue
func (t *PrimitiveTypeValue) MergeBinaryTypeValue(v BinaryTypeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PrimitiveTypeValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PrimitiveTypeValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsScanReport returns the union data inside the ReportMetricsRequest as a ScanReport
func (t ReportMetricsRequest) AsScanReport() (ScanReport, error) {
	var body ScanReport
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScanReport overwrites any union data inside the ReportMetricsRequest as the provided ScanReport
func (t *ReportMetricsRequest) FromScanReport(v ScanReport) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScanReport performs a merge with any union data inside the ReportMetricsRequest, using the provided ScanReport
func (t *ReportMetricsRequest) MergeScanReport(v ScanReport) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCommitReport returns the union data inside the ReportMetricsRequest as a CommitReport
func (t ReportMetricsRequest) AsCommitReport() (CommitReport, error) {
	var body CommitReport
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommitReport overwrites any union data inside the ReportMetricsRequest as the provided CommitReport
func (t *ReportMetricsRequest) FromCommitReport(v CommitReport) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommitReport performs a merge with any union data inside the ReportMetricsRequest, using the provided CommitReport
func (t *ReportMetricsRequest) MergeCommitReport(v CommitReport) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ReportMetricsRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["report-type"], err = json.Marshal(t.ReportType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'report-type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ReportMetricsRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["report-type"]; found {
		err = json.Unmarshal(raw, &t.ReportType)
		if err != nil {
			return fmt.Errorf("error reading 'report-type': %w", err)
		}
	}

	return err
}

// AsAssignUUIDUpdate returns the union data inside the TableUpdate as a AssignUUIDUpdate
func (t TableUpdate) AsAssignUUIDUpdate() (AssignUUIDUpdate, error) {
	var body AssignUUIDUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssignUUIDUpdate overwrites any union data inside the TableUpdate as the provided AssignUUIDUpdate
func (t *TableUpdate) FromAssignUUIDUpdate(v AssignUUIDUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssignUUIDUpdate performs a merge with any union data inside the TableUpdate, using the provided AssignUUIDUpdate
func (t *TableUpdate) MergeAssignUUIDUpdate(v AssignUUIDUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpgradeFormatVersionUpdate returns the union data inside the TableUpdate as a UpgradeFormatVersionUpdate
func (t TableUpdate) AsUpgradeFormatVersionUpdate() (UpgradeFormatVersionUpdate, error) {
	var body UpgradeFormatVersionUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpgradeFormatVersionUpdate overwrites any union data inside the TableUpdate as the provided UpgradeFormatVersionUpdate
func (t *TableUpdate) FromUpgradeFormatVersionUpdate(v UpgradeFormatVersionUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpgradeFormatVersionUpdate performs a merge with any union data inside the TableUpdate, using the provided UpgradeFormatVersionUpdate
func (t *TableUpdate) MergeUpgradeFormatVersionUpdate(v UpgradeFormatVersionUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAddSchemaUpdate returns the union data inside the TableUpdate as a AddSchemaUpdate
func (t TableUpdate) AsAddSchemaUpdate() (AddSchemaUpdate, error) {
	var body AddSchemaUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddSchemaUpdate overwrites any union data inside the TableUpdate as the provided AddSchemaUpdate
func (t *TableUpdate) FromAddSchemaUpdate(v AddSchemaUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddSchemaUpdate performs a merge with any union data inside the TableUpdate, using the provided AddSchemaUpdate
func (t *TableUpdate) MergeAddSchemaUpdate(v AddSchemaUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetCurrentSchemaUpdate returns the union data inside the TableUpdate as a SetCurrentSchemaUpdate
func (t TableUpdate) AsSetCurrentSchemaUpdate() (SetCurrentSchemaUpdate, error) {
	var body SetCurrentSchemaUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetCurrentSchemaUpdate overwrites any union data inside the TableUpdate as the provided SetCurrentSchemaUpdate
func (t *TableUpdate) FromSetCurrentSchemaUpdate(v SetCurrentSchemaUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetCurrentSchemaUpdate performs a merge with any union data inside the TableUpdate, using the provided SetCurrentSchemaUpdate
func (t *TableUpdate) MergeSetCurrentSchemaUpdate(v SetCurrentSchemaUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAddPartitionSpecUpdate returns the union data inside the TableUpdate as a AddPartitionSpecUpdate
func (t TableUpdate) AsAddPartitionSpecUpdate() (AddPartitionSpecUpdate, error) {
	var body AddPartitionSpecUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddPartitionSpecUpdate overwrites any union data inside the TableUpdate as the provided AddPartitionSpecUpdate
func (t *TableUpdate) FromAddPartitionSpecUpdate(v AddPartitionSpecUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddPartitionSpecUpdate performs a merge with any union data inside the TableUpdate, using the provided AddPartitionSpecUpdate
func (t *TableUpdate) MergeAddPartitionSpecUpdate(v AddPartitionSpecUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetDefaultSpecUpdate returns the union data inside the TableUpdate as a SetDefaultSpecUpdate
func (t TableUpdate) AsSetDefaultSpecUpdate() (SetDefaultSpecUpdate, error) {
	var body SetDefaultSpecUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetDefaultSpecUpdate overwrites any union data inside the TableUpdate as the provided SetDefaultSpecUpdate
func (t *TableUpdate) FromSetDefaultSpecUpdate(v SetDefaultSpecUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetDefaultSpecUpdate performs a merge with any union data inside the TableUpdate, using the provided SetDefaultSpecUpdate
func (t *TableUpdate) MergeSetDefaultSpecUpdate(v SetDefaultSpecUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAddSortOrderUpdate returns the union data inside the TableUpdate as a AddSortOrderUpdate
func (t TableUpdate) AsAddSortOrderUpdate() (AddSortOrderUpdate, error) {
	var body AddSortOrderUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddSortOrderUpdate overwrites any union data inside the TableUpdate as the provided AddSortOrderUpdate
func (t *TableUpdate) FromAddSortOrderUpdate(v AddSortOrderUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddSortOrderUpdate performs a merge with any union data inside the TableUpdate, using the provided AddSortOrderUpdate
func (t *TableUpdate) MergeAddSortOrderUpdate(v AddSortOrderUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetDefaultSortOrderUpdate returns the union data inside the TableUpdate as a SetDefaultSortOrderUpdate
func (t TableUpdate) AsSetDefaultSortOrderUpdate() (SetDefaultSortOrderUpdate, error) {
	var body SetDefaultSortOrderUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetDefaultSortOrderUpdate overwrites any union data inside the TableUpdate as the provided SetDefaultSortOrderUpdate
func (t *TableUpdate) FromSetDefaultSortOrderUpdate(v SetDefaultSortOrderUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetDefaultSortOrderUpdate performs a merge with any union data inside the TableUpdate, using the provided SetDefaultSortOrderUpdate
func (t *TableUpdate) MergeSetDefaultSortOrderUpdate(v SetDefaultSortOrderUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAddSnapshotUpdate returns the union data inside the TableUpdate as a AddSnapshotUpdate
func (t TableUpdate) AsAddSnapshotUpdate() (AddSnapshotUpdate, error) {
	var body AddSnapshotUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddSnapshotUpdate overwrites any union data inside the TableUpdate as the provided AddSnapshotUpdate
func (t *TableUpdate) FromAddSnapshotUpdate(v AddSnapshotUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddSnapshotUpdate performs a merge with any union data inside the TableUpdate, using the provided AddSnapshotUpdate
func (t *TableUpdate) MergeAddSnapshotUpdate(v AddSnapshotUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetSnapshotRefUpdate returns the union data inside the TableUpdate as a SetSnapshotRefUpdate
func (t TableUpdate) AsSetSnapshotRefUpdate() (SetSnapshotRefUpdate, error) {
	var body SetSnapshotRefUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetSnapshotRefUpdate overwrites any union data inside the TableUpdate as the provided SetSnapshotRefUpdate
func (t *TableUpdate) FromSetSnapshotRefUpdate(v SetSnapshotRefUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetSnapshotRefUpdate performs a merge with any union data inside the TableUpdate, using the provided SetSnapshotRefUpdate
func (t *TableUpdate) MergeSetSnapshotRefUpdate(v SetSnapshotRefUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRemoveSnapshotsUpdate returns the union data inside the TableUpdate as a RemoveSnapshotsUpdate
func (t TableUpdate) AsRemoveSnapshotsUpdate() (RemoveSnapshotsUpdate, error) {
	var body RemoveSnapshotsUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemoveSnapshotsUpdate overwrites any union data inside the TableUpdate as the provided RemoveSnapshotsUpdate
func (t *TableUpdate) FromRemoveSnapshotsUpdate(v RemoveSnapshotsUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemoveSnapshotsUpdate performs a merge with any union data inside the TableUpdate, using the provided RemoveSnapshotsUpdate
func (t *TableUpdate) MergeRemoveSnapshotsUpdate(v RemoveSnapshotsUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRemoveSnapshotRefUpdate returns the union data inside the TableUpdate as a RemoveSnapshotRefUpdate
func (t TableUpdate) AsRemoveSnapshotRefUpdate() (RemoveSnapshotRefUpdate, error) {
	var body RemoveSnapshotRefUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemoveSnapshotRefUpdate overwrites any union data inside the TableUpdate as the provided RemoveSnapshotRefUpdate
func (t *TableUpdate) FromRemoveSnapshotRefUpdate(v RemoveSnapshotRefUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemoveSnapshotRefUpdate performs a merge with any union data inside the TableUpdate, using the provided RemoveSnapshotRefUpdate
func (t *TableUpdate) MergeRemoveSnapshotRefUpdate(v RemoveSnapshotRefUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetLocationUpdate returns the union data inside the TableUpdate as a SetLocationUpdate
func (t TableUpdate) AsSetLocationUpdate() (SetLocationUpdate, error) {
	var body SetLocationUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetLocationUpdate overwrites any union data inside the TableUpdate as the provided SetLocationUpdate
func (t *TableUpdate) FromSetLocationUpdate(v SetLocationUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetLocationUpdate performs a merge with any union data inside the TableUpdate, using the provided SetLocationUpdate
func (t *TableUpdate) MergeSetLocationUpdate(v SetLocationUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetPropertiesUpdate returns the union data inside the TableUpdate as a SetPropertiesUpdate
func (t TableUpdate) AsSetPropertiesUpdate() (SetPropertiesUpdate, error) {
	var body SetPropertiesUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetPropertiesUpdate overwrites any union data inside the TableUpdate as the provided SetPropertiesUpdate
func (t *TableUpdate) FromSetPropertiesUpdate(v SetPropertiesUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetPropertiesUpdate performs a merge with any union data inside the TableUpdate, using the provided SetPropertiesUpdate
func (t *TableUpdate) MergeSetPropertiesUpdate(v SetPropertiesUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRemovePropertiesUpdate returns the union data inside the TableUpdate as a RemovePropertiesUpdate
func (t TableUpdate) AsRemovePropertiesUpdate() (RemovePropertiesUpdate, error) {
	var body RemovePropertiesUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemovePropertiesUpdate overwrites any union data inside the TableUpdate as the provided RemovePropertiesUpdate
func (t *TableUpdate) FromRemovePropertiesUpdate(v RemovePropertiesUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemovePropertiesUpdate performs a merge with any union data inside the TableUpdate, using the provided RemovePropertiesUpdate
func (t *TableUpdate) MergeRemovePropertiesUpdate(v RemovePropertiesUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetStatisticsUpdate returns the union data inside the TableUpdate as a SetStatisticsUpdate
func (t TableUpdate) AsSetStatisticsUpdate() (SetStatisticsUpdate, error) {
	var body SetStatisticsUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetStatisticsUpdate overwrites any union data inside the TableUpdate as the provided SetStatisticsUpdate
func (t *TableUpdate) FromSetStatisticsUpdate(v SetStatisticsUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetStatisticsUpdate performs a merge with any union data inside the TableUpdate, using the provided SetStatisticsUpdate
func (t *TableUpdate) MergeSetStatisticsUpdate(v SetStatisticsUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRemoveStatisticsUpdate returns the union data inside the TableUpdate as a RemoveStatisticsUpdate
func (t TableUpdate) AsRemoveStatisticsUpdate() (RemoveStatisticsUpdate, error) {
	var body RemoveStatisticsUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemoveStatisticsUpdate overwrites any union data inside the TableUpdate as the provided RemoveStatisticsUpdate
func (t *TableUpdate) FromRemoveStatisticsUpdate(v RemoveStatisticsUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemoveStatisticsUpdate performs a merge with any union data inside the TableUpdate, using the provided RemoveStatisticsUpdate
func (t *TableUpdate) MergeRemoveStatisticsUpdate(v RemoveStatisticsUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRemovePartitionSpecsUpdate returns the union data inside the TableUpdate as a RemovePartitionSpecsUpdate
func (t TableUpdate) AsRemovePartitionSpecsUpdate() (RemovePartitionSpecsUpdate, error) {
	var body RemovePartitionSpecsUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemovePartitionSpecsUpdate overwrites any union data inside the TableUpdate as the provided RemovePartitionSpecsUpdate
func (t *TableUpdate) FromRemovePartitionSpecsUpdate(v RemovePartitionSpecsUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemovePartitionSpecsUpdate performs a merge with any union data inside the TableUpdate, using the provided RemovePartitionSpecsUpdate
func (t *TableUpdate) MergeRemovePartitionSpecsUpdate(v RemovePartitionSpecsUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnableRowLineageUpdate returns the union data inside the TableUpdate as a EnableRowLineageUpdate
func (t TableUpdate) AsEnableRowLineageUpdate() (EnableRowLineageUpdate, error) {
	var body EnableRowLineageUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnableRowLineageUpdate overwrites any union data inside the TableUpdate as the provided EnableRowLineageUpdate
func (t *TableUpdate) FromEnableRowLineageUpdate(v EnableRowLineageUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnableRowLineageUpdate performs a merge with any union data inside the TableUpdate, using the provided EnableRowLineageUpdate
func (t *TableUpdate) MergeEnableRowLineageUpdate(v EnableRowLineageUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TableUpdate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TableUpdate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsReference returns the union data inside the Term as a Reference
func (t Term) AsReference() (Reference, error) {
	var body Reference
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReference overwrites any union data inside the Term as the provided Reference
func (t *Term) FromReference(v Reference) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReference performs a merge with any union data inside the Term, using the provided Reference
func (t *Term) MergeReference(v Reference) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTransformTerm returns the union data inside the Term as a TransformTerm
func (t Term) AsTransformTerm() (TransformTerm, error) {
	var body TransformTerm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransformTerm overwrites any union data inside the Term as the provided TransformTerm
func (t *Term) FromTransformTerm(v TransformTerm) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransformTerm performs a merge with any union data inside the Term, using the provided TransformTerm
func (t *Term) MergeTransformTerm(v TransformTerm) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Term) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Term) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPrimitiveType returns the union data inside the Type as a PrimitiveType
func (t Type) AsPrimitiveType() (PrimitiveType, error) {
	var body PrimitiveType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrimitiveType overwrites any union data inside the Type as the provided PrimitiveType
func (t *Type) FromPrimitiveType(v PrimitiveType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrimitiveType performs a merge with any union data inside the Type, using the provided PrimitiveType
func (t *Type) MergePrimitiveType(v PrimitiveType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStructType returns the union data inside the Type as a StructType
func (t Type) AsStructType() (StructType, error) {
	var body StructType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStructType overwrites any union data inside the Type as the provided StructType
func (t *Type) FromStructType(v StructType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStructType performs a merge with any union data inside the Type, using the provided StructType
func (t *Type) MergeStructType(v StructType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsListType returns the union data inside the Type as a ListType
func (t Type) AsListType() (ListType, error) {
	var body ListType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromListType overwrites any union data inside the Type as the provided ListType
func (t *Type) FromListType(v ListType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeListType performs a merge with any union data inside the Type, using the provided ListType
func (t *Type) MergeListType(v ListType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMapType returns the union data inside the Type as a MapType
func (t Type) AsMapType() (MapType, error) {
	var body MapType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapType overwrites any union data inside the Type as the provided MapType
func (t *Type) FromMapType(v MapType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapType performs a merge with any union data inside the Type, using the provided MapType
func (t *Type) MergeMapType(v MapType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Type) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Type) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSQLViewRepresentation returns the union data inside the ViewRepresentation as a SQLViewRepresentation
func (t ViewRepresentation) AsSQLViewRepresentation() (SQLViewRepresentation, error) {
	var body SQLViewRepresentation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSQLViewRepresentation overwrites any union data inside the ViewRepresentation as the provided SQLViewRepresentation
func (t *ViewRepresentation) FromSQLViewRepresentation(v SQLViewRepresentation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSQLViewRepresentation performs a merge with any union data inside the ViewRepresentation, using the provided SQLViewRepresentation
func (t *ViewRepresentation) MergeSQLViewRepresentation(v SQLViewRepresentation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ViewRepresentation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ViewRepresentation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssertViewUUID returns the union data inside the ViewRequirement as a AssertViewUUID
func (t ViewRequirement) AsAssertViewUUID() (AssertViewUUID, error) {
	var body AssertViewUUID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssertViewUUID overwrites any union data inside the ViewRequirement as the provided AssertViewUUID
func (t *ViewRequirement) FromAssertViewUUID(v AssertViewUUID) error {
	v.Type = "assert-view-uuid"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssertViewUUID performs a merge with any union data inside the ViewRequirement, using the provided AssertViewUUID
func (t *ViewRequirement) MergeAssertViewUUID(v AssertViewUUID) error {
	v.Type = "assert-view-uuid"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ViewRequirement) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ViewRequirement) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "assert-view-uuid":
		return t.AsAssertViewUUID()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ViewRequirement) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ViewRequirement) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssignUUIDUpdate returns the union data inside the ViewUpdate as a AssignUUIDUpdate
func (t ViewUpdate) AsAssignUUIDUpdate() (AssignUUIDUpdate, error) {
	var body AssignUUIDUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssignUUIDUpdate overwrites any union data inside the ViewUpdate as the provided AssignUUIDUpdate
func (t *ViewUpdate) FromAssignUUIDUpdate(v AssignUUIDUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssignUUIDUpdate performs a merge with any union data inside the ViewUpdate, using the provided AssignUUIDUpdate
func (t *ViewUpdate) MergeAssignUUIDUpdate(v AssignUUIDUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpgradeFormatVersionUpdate returns the union data inside the ViewUpdate as a UpgradeFormatVersionUpdate
func (t ViewUpdate) AsUpgradeFormatVersionUpdate() (UpgradeFormatVersionUpdate, error) {
	var body UpgradeFormatVersionUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpgradeFormatVersionUpdate overwrites any union data inside the ViewUpdate as the provided UpgradeFormatVersionUpdate
func (t *ViewUpdate) FromUpgradeFormatVersionUpdate(v UpgradeFormatVersionUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpgradeFormatVersionUpdate performs a merge with any union data inside the ViewUpdate, using the provided UpgradeFormatVersionUpdate
func (t *ViewUpdate) MergeUpgradeFormatVersionUpdate(v UpgradeFormatVersionUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAddSchemaUpdate returns the union data inside the ViewUpdate as a AddSchemaUpdate
func (t ViewUpdate) AsAddSchemaUpdate() (AddSchemaUpdate, error) {
	var body AddSchemaUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddSchemaUpdate overwrites any union data inside the ViewUpdate as the provided AddSchemaUpdate
func (t *ViewUpdate) FromAddSchemaUpdate(v AddSchemaUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddSchemaUpdate performs a merge with any union data inside the ViewUpdate, using the provided AddSchemaUpdate
func (t *ViewUpdate) MergeAddSchemaUpdate(v AddSchemaUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetLocationUpdate returns the union data inside the ViewUpdate as a SetLocationUpdate
func (t ViewUpdate) AsSetLocationUpdate() (SetLocationUpdate, error) {
	var body SetLocationUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetLocationUpdate overwrites any union data inside the ViewUpdate as the provided SetLocationUpdate
func (t *ViewUpdate) FromSetLocationUpdate(v SetLocationUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetLocationUpdate performs a merge with any union data inside the ViewUpdate, using the provided SetLocationUpdate
func (t *ViewUpdate) MergeSetLocationUpdate(v SetLocationUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetPropertiesUpdate returns the union data inside the ViewUpdate as a SetPropertiesUpdate
func (t ViewUpdate) AsSetPropertiesUpdate() (SetPropertiesUpdate, error) {
	var body SetPropertiesUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetPropertiesUpdate overwrites any union data inside the ViewUpdate as the provided SetPropertiesUpdate
func (t *ViewUpdate) FromSetPropertiesUpdate(v SetPropertiesUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetPropertiesUpdate performs a merge with any union data inside the ViewUpdate, using the provided SetPropertiesUpdate
func (t *ViewUpdate) MergeSetPropertiesUpdate(v SetPropertiesUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRemovePropertiesUpdate returns the union data inside the ViewUpdate as a RemovePropertiesUpdate
func (t ViewUpdate) AsRemovePropertiesUpdate() (RemovePropertiesUpdate, error) {
	var body RemovePropertiesUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRemovePropertiesUpdate overwrites any union data inside the ViewUpdate as the provided RemovePropertiesUpdate
func (t *ViewUpdate) FromRemovePropertiesUpdate(v RemovePropertiesUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRemovePropertiesUpdate performs a merge with any union data inside the ViewUpdate, using the provided RemovePropertiesUpdate
func (t *ViewUpdate) MergeRemovePropertiesUpdate(v RemovePropertiesUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAddViewVersionUpdate returns the union data inside the ViewUpdate as a AddViewVersionUpdate
func (t ViewUpdate) AsAddViewVersionUpdate() (AddViewVersionUpdate, error) {
	var body AddViewVersionUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddViewVersionUpdate overwrites any union data inside the ViewUpdate as the provided AddViewVersionUpdate
func (t *ViewUpdate) FromAddViewVersionUpdate(v AddViewVersionUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddViewVersionUpdate performs a merge with any union data inside the ViewUpdate, using the provided AddViewVersionUpdate
func (t *ViewUpdate) MergeAddViewVersionUpdate(v AddViewVersionUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetCurrentViewVersionUpdate returns the union data inside the ViewUpdate as a SetCurrentViewVersionUpdate
func (t ViewUpdate) AsSetCurrentViewVersionUpdate() (SetCurrentViewVersionUpdate, error) {
	var body SetCurrentViewVersionUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetCurrentViewVersionUpdate overwrites any union data inside the ViewUpdate as the provided SetCurrentViewVersionUpdate
func (t *ViewUpdate) FromSetCurrentViewVersionUpdate(v SetCurrentViewVersionUpdate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetCurrentViewVersionUpdate performs a merge with any union data inside the ViewUpdate, using the provided SetCurrentViewVersionUpdate
func (t *ViewUpdate) MergeSetCurrentViewVersionUpdate(v SetCurrentViewVersionUpdate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ViewUpdate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ViewUpdate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetApplicablePolicies request
	GetApplicablePolicies(ctx context.Context, prefix Prefix, params *GetApplicablePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGenericTables request
	ListGenericTables(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListGenericTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGenericTableWithBody request with any body
	CreateGenericTableWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGenericTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body CreateGenericTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DropGenericTable request
	DropGenericTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, genericTableName GenericTableName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadGenericTable request
	LoadGenericTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, genericTableName GenericTableName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPolicies request
	ListPolicies(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePolicyWithBody request with any body
	CreatePolicyWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePolicy(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DropPolicy request
	DropPolicy(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, params *DropPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadPolicy request
	LoadPolicy(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicyWithBody request with any body
	UpdatePolicyWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicy(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DetachPolicyWithBody request with any body
	DetachPolicyWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DetachPolicy(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body DetachPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachPolicyWithBody request with any body
	AttachPolicyWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachPolicy(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body AttachPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokenWithBody request with any body
	GetTokenWithBody(ctx context.Context, params *GetTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetTokenWithFormdataBody(ctx context.Context, params *GetTokenParams, body GetTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNamespaces request
	ListNamespaces(ctx context.Context, prefix Prefix, params *ListNamespacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNamespaceWithBody request with any body
	CreateNamespaceWithBody(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNamespace(ctx context.Context, prefix Prefix, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DropNamespace request
	DropNamespace(ctx context.Context, prefix Prefix, namespaceString NamespaceString, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadNamespaceMetadata request
	LoadNamespaceMetadata(ctx context.Context, prefix Prefix, namespaceString NamespaceString, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespaceExists request
	NamespaceExists(ctx context.Context, prefix Prefix, namespaceString NamespaceString, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePropertiesWithBody request with any body
	UpdatePropertiesWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProperties(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body UpdatePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterTableWithBody request with any body
	RegisterTableWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body RegisterTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTables request
	ListTables(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTableWithBody request with any body
	CreateTableWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DropTable request
	DropTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, params *DropTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadTable request
	LoadTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, params *LoadTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TableExists request
	TableExists(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTableWithBody request with any body
	UpdateTableWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadCredentials request
	LoadCredentials(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReportMetricsWithBody request with any body
	ReportMetricsWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReportMetrics(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, body ReportMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendNotificationWithBody request with any body
	SendNotificationWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendNotification(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, body SendNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListViews request
	ListViews(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListViewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateViewWithBody request with any body
	CreateViewWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateView(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body CreateViewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DropView request
	DropView(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadView request
	LoadView(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ViewExists request
	ViewExists(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceViewWithBody request with any body
	ReplaceViewWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceView(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, body ReplaceViewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RenameTableWithBody request with any body
	RenameTableWithBody(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RenameTable(ctx context.Context, prefix Prefix, body RenameTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitTransactionWithBody request with any body
	CommitTransactionWithBody(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommitTransaction(ctx context.Context, prefix Prefix, body CommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RenameViewWithBody request with any body
	RenameViewWithBody(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RenameView(ctx context.Context, prefix Prefix, body RenameViewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetApplicablePolicies(ctx context.Context, prefix Prefix, params *GetApplicablePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicablePoliciesRequest(c.Server, prefix, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGenericTables(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListGenericTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGenericTablesRequest(c.Server, prefix, namespaceString, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGenericTableWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGenericTableRequestWithBody(c.Server, prefix, namespaceString, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGenericTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body CreateGenericTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGenericTableRequest(c.Server, prefix, namespaceString, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DropGenericTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, genericTableName GenericTableName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropGenericTableRequest(c.Server, prefix, namespaceString, genericTableName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadGenericTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, genericTableName GenericTableName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadGenericTableRequest(c.Server, prefix, namespaceString, genericTableName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPolicies(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPoliciesRequest(c.Server, prefix, namespaceString, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicyWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequestWithBody(c.Server, prefix, namespaceString, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicy(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequest(c.Server, prefix, namespaceString, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DropPolicy(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, params *DropPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropPolicyRequest(c.Server, prefix, namespaceString, policyName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadPolicy(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadPolicyRequest(c.Server, prefix, namespaceString, policyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicyWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequestWithBody(c.Server, prefix, namespaceString, policyName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicy(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequest(c.Server, prefix, namespaceString, policyName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DetachPolicyWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDetachPolicyRequestWithBody(c.Server, prefix, namespaceString, policyName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DetachPolicy(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body DetachPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDetachPolicyRequest(c.Server, prefix, namespaceString, policyName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPolicyWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPolicyRequestWithBody(c.Server, prefix, namespaceString, policyName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPolicy(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body AttachPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPolicyRequest(c.Server, prefix, namespaceString, policyName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokenWithBody(ctx context.Context, params *GetTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokenWithFormdataBody(ctx context.Context, params *GetTokenParams, body GetTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNamespaces(ctx context.Context, prefix Prefix, params *ListNamespacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNamespacesRequest(c.Server, prefix, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNamespaceWithBody(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNamespaceRequestWithBody(c.Server, prefix, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNamespace(ctx context.Context, prefix Prefix, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNamespaceRequest(c.Server, prefix, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DropNamespace(ctx context.Context, prefix Prefix, namespaceString NamespaceString, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropNamespaceRequest(c.Server, prefix, namespaceString)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadNamespaceMetadata(ctx context.Context, prefix Prefix, namespaceString NamespaceString, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadNamespaceMetadataRequest(c.Server, prefix, namespaceString)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespaceExists(ctx context.Context, prefix Prefix, namespaceString NamespaceString, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespaceExistsRequest(c.Server, prefix, namespaceString)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePropertiesWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePropertiesRequestWithBody(c.Server, prefix, namespaceString, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProperties(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body UpdatePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePropertiesRequest(c.Server, prefix, namespaceString, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterTableWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterTableRequestWithBody(c.Server, prefix, namespaceString, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body RegisterTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterTableRequest(c.Server, prefix, namespaceString, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTables(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTablesRequest(c.Server, prefix, namespaceString, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTableWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequestWithBody(c.Server, prefix, namespaceString, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequest(c.Server, prefix, namespaceString, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DropTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, params *DropTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropTableRequest(c.Server, prefix, namespaceString, table, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, params *LoadTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadTableRequest(c.Server, prefix, namespaceString, table, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TableExists(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTableExistsRequest(c.Server, prefix, namespaceString, table)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTableWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTableRequestWithBody(c.Server, prefix, namespaceString, table, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTable(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTableRequest(c.Server, prefix, namespaceString, table, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadCredentials(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadCredentialsRequest(c.Server, prefix, namespaceString, table)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportMetricsWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportMetricsRequestWithBody(c.Server, prefix, namespaceString, table, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportMetrics(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, body ReportMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportMetricsRequest(c.Server, prefix, namespaceString, table, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendNotificationWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendNotificationRequestWithBody(c.Server, prefix, namespaceString, table, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendNotification(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, body SendNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendNotificationRequest(c.Server, prefix, namespaceString, table, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListViews(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListViewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListViewsRequest(c.Server, prefix, namespaceString, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateViewWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateViewRequestWithBody(c.Server, prefix, namespaceString, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateView(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body CreateViewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateViewRequest(c.Server, prefix, namespaceString, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DropView(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDropViewRequest(c.Server, prefix, namespaceString, view)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadView(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadViewRequest(c.Server, prefix, namespaceString, view)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ViewExists(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewViewExistsRequest(c.Server, prefix, namespaceString, view)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceViewWithBody(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceViewRequestWithBody(c.Server, prefix, namespaceString, view, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceView(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, body ReplaceViewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceViewRequest(c.Server, prefix, namespaceString, view, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameTableWithBody(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameTableRequestWithBody(c.Server, prefix, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameTable(ctx context.Context, prefix Prefix, body RenameTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameTableRequest(c.Server, prefix, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitTransactionWithBody(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitTransactionRequestWithBody(c.Server, prefix, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitTransaction(ctx context.Context, prefix Prefix, body CommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitTransactionRequest(c.Server, prefix, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameViewWithBody(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameViewRequestWithBody(c.Server, prefix, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameView(ctx context.Context, prefix Prefix, body RenameViewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameViewRequest(c.Server, prefix, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetApplicablePoliciesRequest generates requests for GetApplicablePolicies
func NewGetApplicablePoliciesRequest(server string, prefix Prefix, params *GetApplicablePoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polaris/v1/%s/applicable-policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Namespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "namespace", runtime.ParamLocationQuery, *params.Namespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target-name", runtime.ParamLocationQuery, *params.TargetName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "policyType", runtime.ParamLocationQuery, *params.PolicyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGenericTablesRequest generates requests for ListGenericTables
func NewListGenericTablesRequest(server string, prefix Prefix, namespaceString NamespaceString, params *ListGenericTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polaris/v1/%s/namespaces/%s/generic-tables", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGenericTableRequest calls the generic CreateGenericTable builder with application/json body
func NewCreateGenericTableRequest(server string, prefix Prefix, namespaceString NamespaceString, body CreateGenericTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGenericTableRequestWithBody(server, prefix, namespaceString, "application/json", bodyReader)
}

// NewCreateGenericTableRequestWithBody generates requests for CreateGenericTable with any type of body
func NewCreateGenericTableRequestWithBody(server string, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polaris/v1/%s/namespaces/%s/generic-tables", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDropGenericTableRequest generates requests for DropGenericTable
func NewDropGenericTableRequest(server string, prefix Prefix, namespaceString NamespaceString, genericTableName GenericTableName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "generic-table", runtime.ParamLocationPath, genericTableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polaris/v1/%s/namespaces/%s/generic-tables/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadGenericTableRequest generates requests for LoadGenericTable
func NewLoadGenericTableRequest(server string, prefix Prefix, namespaceString NamespaceString, genericTableName GenericTableName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "generic-table", runtime.ParamLocationPath, genericTableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polaris/v1/%s/namespaces/%s/generic-tables/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPoliciesRequest generates requests for ListPolicies
func NewListPoliciesRequest(server string, prefix Prefix, namespaceString NamespaceString, params *ListPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polaris/v1/%s/namespaces/%s/policies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "policyType", runtime.ParamLocationQuery, *params.PolicyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePolicyRequest calls the generic CreatePolicy builder with application/json body
func NewCreatePolicyRequest(server string, prefix Prefix, namespaceString NamespaceString, body CreatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePolicyRequestWithBody(server, prefix, namespaceString, "application/json", bodyReader)
}

// NewCreatePolicyRequestWithBody generates requests for CreatePolicy with any type of body
func NewCreatePolicyRequestWithBody(server string, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polaris/v1/%s/namespaces/%s/policies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDropPolicyRequest generates requests for DropPolicy
func NewDropPolicyRequest(server string, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, params *DropPolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "policy-name", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polaris/v1/%s/namespaces/%s/policies/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DetachAll != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "detach-all", runtime.ParamLocationQuery, *params.DetachAll); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadPolicyRequest generates requests for LoadPolicy
func NewLoadPolicyRequest(server string, prefix Prefix, namespaceString NamespaceString, policyName PolicyName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "policy-name", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polaris/v1/%s/namespaces/%s/policies/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePolicyRequest calls the generic UpdatePolicy builder with application/json body
func NewUpdatePolicyRequest(server string, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body UpdatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyRequestWithBody(server, prefix, namespaceString, policyName, "application/json", bodyReader)
}

// NewUpdatePolicyRequestWithBody generates requests for UpdatePolicy with any type of body
func NewUpdatePolicyRequestWithBody(server string, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "policy-name", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polaris/v1/%s/namespaces/%s/policies/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDetachPolicyRequest calls the generic DetachPolicy builder with application/json body
func NewDetachPolicyRequest(server string, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body DetachPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDetachPolicyRequestWithBody(server, prefix, namespaceString, policyName, "application/json", bodyReader)
}

// NewDetachPolicyRequestWithBody generates requests for DetachPolicy with any type of body
func NewDetachPolicyRequestWithBody(server string, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "policy-name", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polaris/v1/%s/namespaces/%s/policies/%s/mappings", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAttachPolicyRequest calls the generic AttachPolicy builder with application/json body
func NewAttachPolicyRequest(server string, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body AttachPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachPolicyRequestWithBody(server, prefix, namespaceString, policyName, "application/json", bodyReader)
}

// NewAttachPolicyRequestWithBody generates requests for AttachPolicy with any type of body
func NewAttachPolicyRequestWithBody(server string, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "policy-name", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polaris/v1/%s/namespaces/%s/policies/%s/mappings", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string, params *GetConfigParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Warehouse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "warehouse", runtime.ParamLocationQuery, *params.Warehouse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenRequestWithFormdataBody calls the generic GetToken builder with application/x-www-form-urlencoded body
func NewGetTokenRequestWithFormdataBody(server string, params *GetTokenParams, body GetTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewGetTokenRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewGetTokenRequestWithBody generates requests for GetToken with any type of body
func NewGetTokenRequestWithBody(server string, params *GetTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Authorization", headerParam0)
		}

	}

	return req, nil
}

// NewListNamespacesRequest generates requests for ListNamespaces
func NewListNamespacesRequest(server string, prefix Prefix, params *ListNamespacesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Parent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent", runtime.ParamLocationQuery, *params.Parent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNamespaceRequest calls the generic CreateNamespace builder with application/json body
func NewCreateNamespaceRequest(server string, prefix Prefix, body CreateNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNamespaceRequestWithBody(server, prefix, "application/json", bodyReader)
}

// NewCreateNamespaceRequestWithBody generates requests for CreateNamespace with any type of body
func NewCreateNamespaceRequestWithBody(server string, prefix Prefix, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDropNamespaceRequest generates requests for DropNamespace
func NewDropNamespaceRequest(server string, prefix Prefix, namespaceString NamespaceString) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadNamespaceMetadataRequest generates requests for LoadNamespaceMetadata
func NewLoadNamespaceMetadataRequest(server string, prefix Prefix, namespaceString NamespaceString) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespaceExistsRequest generates requests for NamespaceExists
func NewNamespaceExistsRequest(server string, prefix Prefix, namespaceString NamespaceString) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePropertiesRequest calls the generic UpdateProperties builder with application/json body
func NewUpdatePropertiesRequest(server string, prefix Prefix, namespaceString NamespaceString, body UpdatePropertiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePropertiesRequestWithBody(server, prefix, namespaceString, "application/json", bodyReader)
}

// NewUpdatePropertiesRequestWithBody generates requests for UpdateProperties with any type of body
func NewUpdatePropertiesRequestWithBody(server string, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/properties", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRegisterTableRequest calls the generic RegisterTable builder with application/json body
func NewRegisterTableRequest(server string, prefix Prefix, namespaceString NamespaceString, body RegisterTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterTableRequestWithBody(server, prefix, namespaceString, "application/json", bodyReader)
}

// NewRegisterTableRequestWithBody generates requests for RegisterTable with any type of body
func NewRegisterTableRequestWithBody(server string, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/register", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTablesRequest generates requests for ListTables
func NewListTablesRequest(server string, prefix Prefix, namespaceString NamespaceString, params *ListTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/tables", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTableRequest calls the generic CreateTable builder with application/json body
func NewCreateTableRequest(server string, prefix Prefix, namespaceString NamespaceString, params *CreateTableParams, body CreateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTableRequestWithBody(server, prefix, namespaceString, params, "application/json", bodyReader)
}

// NewCreateTableRequestWithBody generates requests for CreateTable with any type of body
func NewCreateTableRequestWithBody(server string, prefix Prefix, namespaceString NamespaceString, params *CreateTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/tables", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIcebergAccessDelegation != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Iceberg-Access-Delegation", runtime.ParamLocationHeader, *params.XIcebergAccessDelegation)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Iceberg-Access-Delegation", headerParam0)
		}

	}

	return req, nil
}

// NewDropTableRequest generates requests for DropTable
func NewDropTableRequest(server string, prefix Prefix, namespaceString NamespaceString, table Table, params *DropTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "table", runtime.ParamLocationPath, table)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/tables/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PurgeRequested != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "purgeRequested", runtime.ParamLocationQuery, *params.PurgeRequested); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadTableRequest generates requests for LoadTable
func NewLoadTableRequest(server string, prefix Prefix, namespaceString NamespaceString, table Table, params *LoadTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "table", runtime.ParamLocationPath, table)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/tables/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Snapshots != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "snapshots", runtime.ParamLocationQuery, *params.Snapshots); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XIcebergAccessDelegation != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Iceberg-Access-Delegation", runtime.ParamLocationHeader, *params.XIcebergAccessDelegation)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Iceberg-Access-Delegation", headerParam0)
		}

		if params.IfNoneMatch != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-None-Match", headerParam1)
		}

	}

	return req, nil
}

// NewTableExistsRequest generates requests for TableExists
func NewTableExistsRequest(server string, prefix Prefix, namespaceString NamespaceString, table Table) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "table", runtime.ParamLocationPath, table)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/tables/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTableRequest calls the generic UpdateTable builder with application/json body
func NewUpdateTableRequest(server string, prefix Prefix, namespaceString NamespaceString, table Table, body UpdateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTableRequestWithBody(server, prefix, namespaceString, table, "application/json", bodyReader)
}

// NewUpdateTableRequestWithBody generates requests for UpdateTable with any type of body
func NewUpdateTableRequestWithBody(server string, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "table", runtime.ParamLocationPath, table)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/tables/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLoadCredentialsRequest generates requests for LoadCredentials
func NewLoadCredentialsRequest(server string, prefix Prefix, namespaceString NamespaceString, table Table) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "table", runtime.ParamLocationPath, table)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/tables/%s/credentials", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReportMetricsRequest calls the generic ReportMetrics builder with application/json body
func NewReportMetricsRequest(server string, prefix Prefix, namespaceString NamespaceString, table Table, body ReportMetricsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReportMetricsRequestWithBody(server, prefix, namespaceString, table, "application/json", bodyReader)
}

// NewReportMetricsRequestWithBody generates requests for ReportMetrics with any type of body
func NewReportMetricsRequestWithBody(server string, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "table", runtime.ParamLocationPath, table)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/tables/%s/metrics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendNotificationRequest calls the generic SendNotification builder with application/json body
func NewSendNotificationRequest(server string, prefix Prefix, namespaceString NamespaceString, table Table, body SendNotificationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendNotificationRequestWithBody(server, prefix, namespaceString, table, "application/json", bodyReader)
}

// NewSendNotificationRequestWithBody generates requests for SendNotification with any type of body
func NewSendNotificationRequestWithBody(server string, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "table", runtime.ParamLocationPath, table)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/tables/%s/notifications", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListViewsRequest generates requests for ListViews
func NewListViewsRequest(server string, prefix Prefix, namespaceString NamespaceString, params *ListViewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/views", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateViewRequest calls the generic CreateView builder with application/json body
func NewCreateViewRequest(server string, prefix Prefix, namespaceString NamespaceString, body CreateViewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateViewRequestWithBody(server, prefix, namespaceString, "application/json", bodyReader)
}

// NewCreateViewRequestWithBody generates requests for CreateView with any type of body
func NewCreateViewRequestWithBody(server string, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/views", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDropViewRequest generates requests for DropView
func NewDropViewRequest(server string, prefix Prefix, namespaceString NamespaceString, view View) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "view", runtime.ParamLocationPath, view)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/views/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadViewRequest generates requests for LoadView
func NewLoadViewRequest(server string, prefix Prefix, namespaceString NamespaceString, view View) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "view", runtime.ParamLocationPath, view)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/views/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewViewExistsRequest generates requests for ViewExists
func NewViewExistsRequest(server string, prefix Prefix, namespaceString NamespaceString, view View) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "view", runtime.ParamLocationPath, view)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/views/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceViewRequest calls the generic ReplaceView builder with application/json body
func NewReplaceViewRequest(server string, prefix Prefix, namespaceString NamespaceString, view View, body ReplaceViewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceViewRequestWithBody(server, prefix, namespaceString, view, "application/json", bodyReader)
}

// NewReplaceViewRequestWithBody generates requests for ReplaceView with any type of body
func NewReplaceViewRequestWithBody(server string, prefix Prefix, namespaceString NamespaceString, view View, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespaceString)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "view", runtime.ParamLocationPath, view)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/namespaces/%s/views/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRenameTableRequest calls the generic RenameTable builder with application/json body
func NewRenameTableRequest(server string, prefix Prefix, body RenameTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRenameTableRequestWithBody(server, prefix, "application/json", bodyReader)
}

// NewRenameTableRequestWithBody generates requests for RenameTable with any type of body
func NewRenameTableRequestWithBody(server string, prefix Prefix, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/tables/rename", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommitTransactionRequest calls the generic CommitTransaction builder with application/json body
func NewCommitTransactionRequest(server string, prefix Prefix, body CommitTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommitTransactionRequestWithBody(server, prefix, "application/json", bodyReader)
}

// NewCommitTransactionRequestWithBody generates requests for CommitTransaction with any type of body
func NewCommitTransactionRequestWithBody(server string, prefix Prefix, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/transactions/commit", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRenameViewRequest calls the generic RenameView builder with application/json body
func NewRenameViewRequest(server string, prefix Prefix, body RenameViewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRenameViewRequestWithBody(server, prefix, "application/json", bodyReader)
}

// NewRenameViewRequestWithBody generates requests for RenameView with any type of body
func NewRenameViewRequestWithBody(server string, prefix Prefix, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/%s/views/rename", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetApplicablePoliciesWithResponse request
	GetApplicablePoliciesWithResponse(ctx context.Context, prefix Prefix, params *GetApplicablePoliciesParams, reqEditors ...RequestEditorFn) (*GetApplicablePoliciesResponse, error)

	// ListGenericTablesWithResponse request
	ListGenericTablesWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListGenericTablesParams, reqEditors ...RequestEditorFn) (*ListGenericTablesResponse, error)

	// CreateGenericTableWithBodyWithResponse request with any body
	CreateGenericTableWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGenericTableResponse, error)

	CreateGenericTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body CreateGenericTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGenericTableResponse, error)

	// DropGenericTableWithResponse request
	DropGenericTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, genericTableName GenericTableName, reqEditors ...RequestEditorFn) (*DropGenericTableResponse, error)

	// LoadGenericTableWithResponse request
	LoadGenericTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, genericTableName GenericTableName, reqEditors ...RequestEditorFn) (*LoadGenericTableResponse, error)

	// ListPoliciesWithResponse request
	ListPoliciesWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error)

	// CreatePolicyWithBodyWithResponse request with any body
	CreatePolicyWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	CreatePolicyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	// DropPolicyWithResponse request
	DropPolicyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, params *DropPolicyParams, reqEditors ...RequestEditorFn) (*DropPolicyResponse, error)

	// LoadPolicyWithResponse request
	LoadPolicyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, reqEditors ...RequestEditorFn) (*LoadPolicyResponse, error)

	// UpdatePolicyWithBodyWithResponse request with any body
	UpdatePolicyWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	UpdatePolicyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	// DetachPolicyWithBodyWithResponse request with any body
	DetachPolicyWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DetachPolicyResponse, error)

	DetachPolicyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body DetachPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DetachPolicyResponse, error)

	// AttachPolicyWithBodyWithResponse request with any body
	AttachPolicyWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachPolicyResponse, error)

	AttachPolicyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body AttachPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachPolicyResponse, error)

	// GetConfigWithResponse request
	GetConfigWithResponse(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// GetTokenWithBodyWithResponse request with any body
	GetTokenWithBodyWithResponse(ctx context.Context, params *GetTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetTokenResponse, error)

	GetTokenWithFormdataBodyWithResponse(ctx context.Context, params *GetTokenParams, body GetTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetTokenResponse, error)

	// ListNamespacesWithResponse request
	ListNamespacesWithResponse(ctx context.Context, prefix Prefix, params *ListNamespacesParams, reqEditors ...RequestEditorFn) (*ListNamespacesResponse, error)

	// CreateNamespaceWithBodyWithResponse request with any body
	CreateNamespaceWithBodyWithResponse(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNamespaceResponse, error)

	CreateNamespaceWithResponse(ctx context.Context, prefix Prefix, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNamespaceResponse, error)

	// DropNamespaceWithResponse request
	DropNamespaceWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, reqEditors ...RequestEditorFn) (*DropNamespaceResponse, error)

	// LoadNamespaceMetadataWithResponse request
	LoadNamespaceMetadataWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, reqEditors ...RequestEditorFn) (*LoadNamespaceMetadataResponse, error)

	// NamespaceExistsWithResponse request
	NamespaceExistsWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, reqEditors ...RequestEditorFn) (*NamespaceExistsResponse, error)

	// UpdatePropertiesWithBodyWithResponse request with any body
	UpdatePropertiesWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePropertiesResponse, error)

	UpdatePropertiesWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body UpdatePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePropertiesResponse, error)

	// RegisterTableWithBodyWithResponse request with any body
	RegisterTableWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterTableResponse, error)

	RegisterTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body RegisterTableJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterTableResponse, error)

	// ListTablesWithResponse request
	ListTablesWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListTablesParams, reqEditors ...RequestEditorFn) (*ListTablesResponse, error)

	// CreateTableWithBodyWithResponse request with any body
	CreateTableWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	CreateTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	// DropTableWithResponse request
	DropTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, params *DropTableParams, reqEditors ...RequestEditorFn) (*DropTableResponse, error)

	// LoadTableWithResponse request
	LoadTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, params *LoadTableParams, reqEditors ...RequestEditorFn) (*LoadTableResponse, error)

	// TableExistsWithResponse request
	TableExistsWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, reqEditors ...RequestEditorFn) (*TableExistsResponse, error)

	// UpdateTableWithBodyWithResponse request with any body
	UpdateTableWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTableResponse, error)

	UpdateTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTableResponse, error)

	// LoadCredentialsWithResponse request
	LoadCredentialsWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, reqEditors ...RequestEditorFn) (*LoadCredentialsResponse, error)

	// ReportMetricsWithBodyWithResponse request with any body
	ReportMetricsWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReportMetricsResponse, error)

	ReportMetricsWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, body ReportMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportMetricsResponse, error)

	// SendNotificationWithBodyWithResponse request with any body
	SendNotificationWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendNotificationResponse, error)

	SendNotificationWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, body SendNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*SendNotificationResponse, error)

	// ListViewsWithResponse request
	ListViewsWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListViewsParams, reqEditors ...RequestEditorFn) (*ListViewsResponse, error)

	// CreateViewWithBodyWithResponse request with any body
	CreateViewWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateViewResponse, error)

	CreateViewWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body CreateViewJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateViewResponse, error)

	// DropViewWithResponse request
	DropViewWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, reqEditors ...RequestEditorFn) (*DropViewResponse, error)

	// LoadViewWithResponse request
	LoadViewWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, reqEditors ...RequestEditorFn) (*LoadViewResponse, error)

	// ViewExistsWithResponse request
	ViewExistsWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, reqEditors ...RequestEditorFn) (*ViewExistsResponse, error)

	// ReplaceViewWithBodyWithResponse request with any body
	ReplaceViewWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceViewResponse, error)

	ReplaceViewWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, body ReplaceViewJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceViewResponse, error)

	// RenameTableWithBodyWithResponse request with any body
	RenameTableWithBodyWithResponse(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameTableResponse, error)

	RenameTableWithResponse(ctx context.Context, prefix Prefix, body RenameTableJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameTableResponse, error)

	// CommitTransactionWithBodyWithResponse request with any body
	CommitTransactionWithBodyWithResponse(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitTransactionResponse, error)

	CommitTransactionWithResponse(ctx context.Context, prefix Prefix, body CommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitTransactionResponse, error)

	// RenameViewWithBodyWithResponse request with any body
	RenameViewWithBodyWithResponse(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameViewResponse, error)

	RenameViewWithResponse(ctx context.Context, prefix Prefix, body RenameViewJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameViewResponse, error)
}

type GetApplicablePoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetApplicablePoliciesResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetApplicablePoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicablePoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGenericTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListGenericTablesResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListGenericTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGenericTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGenericTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateGenericTableResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON409      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateGenericTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGenericTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DropGenericTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r DropGenericTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DropGenericTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadGenericTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadGenericTableResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r LoadGenericTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadGenericTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPoliciesResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePolicyResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON409      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DropPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *IcebergErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r DropPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DropPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadPolicyResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r LoadPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatePolicyResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON409      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DetachPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r DetachPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DetachPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON409      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r AttachPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CatalogConfig
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthTokenResponse
	JSON400      *OAuthErrorResponse
	JSON401      *OAuthErrorResponse
	JSON5XX      *OAuthErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListNamespacesResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateNamespaceResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON406      *UnsupportedOperationResponse
	JSON409      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DropNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r DropNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DropNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadNamespaceMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetNamespaceResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r LoadNamespaceMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadNamespaceMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespaceExistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r NamespaceExistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespaceExistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateNamespacePropertiesResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON406      *UnsupportedOperationResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON422      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdatePropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadTableResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON409      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r RegisterTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTablesResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateTableResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON409      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DropTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r DropTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DropTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadTableResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r LoadTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TableExistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r TableExistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TableExistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitTableResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON409      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON500      *IcebergErrorResponse
	JSON502      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON504      *IcebergErrorResponse
	JSON5XX      *IcebergErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadCredentialsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r LoadCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReportMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ReportMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReportMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON409      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListViewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTablesResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *ErrorModel
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListViewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListViewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateViewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadViewResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *ErrorModel
	JSON409      *ErrorModel
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateViewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateViewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DropViewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *ErrorModel
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r DropViewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DropViewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadViewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadViewResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *ErrorModel
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r LoadViewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadViewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ViewExistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ViewExistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ViewExistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceViewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadViewResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *ErrorModel
	JSON409      *ErrorModel
	JSON419      *AuthenticationTimeoutResponse
	JSON500      *ErrorModel
	JSON502      *ErrorModel
	JSON503      *ServiceUnavailableResponse
	JSON504      *ErrorModel
	JSON5XX      *ErrorModel
}

// Status returns HTTPResponse.Status
func (r ReplaceViewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceViewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RenameTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON406      *UnsupportedOperationResponse
	JSON409      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r RenameTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RenameTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *IcebergErrorResponse
	JSON409      *IcebergErrorResponse
	JSON419      *AuthenticationTimeoutResponse
	JSON500      *IcebergErrorResponse
	JSON502      *IcebergErrorResponse
	JSON503      *ServiceUnavailableResponse
	JSON504      *IcebergErrorResponse
	JSON5XX      *IcebergErrorResponse
}

// Status returns HTTPResponse.Status
func (r CommitTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RenameViewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON401      *UnauthorizedResponse
	JSON403      *ForbiddenResponse
	JSON404      *ErrorModel
	JSON406      *UnsupportedOperationResponse
	JSON409      *ErrorModel
	JSON419      *AuthenticationTimeoutResponse
	JSON503      *ServiceUnavailableResponse
	JSON5XX      *ServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r RenameViewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RenameViewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetApplicablePoliciesWithResponse request returning *GetApplicablePoliciesResponse
func (c *ClientWithResponses) GetApplicablePoliciesWithResponse(ctx context.Context, prefix Prefix, params *GetApplicablePoliciesParams, reqEditors ...RequestEditorFn) (*GetApplicablePoliciesResponse, error) {
	rsp, err := c.GetApplicablePolicies(ctx, prefix, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicablePoliciesResponse(rsp)
}

// ListGenericTablesWithResponse request returning *ListGenericTablesResponse
func (c *ClientWithResponses) ListGenericTablesWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListGenericTablesParams, reqEditors ...RequestEditorFn) (*ListGenericTablesResponse, error) {
	rsp, err := c.ListGenericTables(ctx, prefix, namespaceString, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGenericTablesResponse(rsp)
}

// CreateGenericTableWithBodyWithResponse request with arbitrary body returning *CreateGenericTableResponse
func (c *ClientWithResponses) CreateGenericTableWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGenericTableResponse, error) {
	rsp, err := c.CreateGenericTableWithBody(ctx, prefix, namespaceString, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGenericTableResponse(rsp)
}

func (c *ClientWithResponses) CreateGenericTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body CreateGenericTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGenericTableResponse, error) {
	rsp, err := c.CreateGenericTable(ctx, prefix, namespaceString, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGenericTableResponse(rsp)
}

// DropGenericTableWithResponse request returning *DropGenericTableResponse
func (c *ClientWithResponses) DropGenericTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, genericTableName GenericTableName, reqEditors ...RequestEditorFn) (*DropGenericTableResponse, error) {
	rsp, err := c.DropGenericTable(ctx, prefix, namespaceString, genericTableName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropGenericTableResponse(rsp)
}

// LoadGenericTableWithResponse request returning *LoadGenericTableResponse
func (c *ClientWithResponses) LoadGenericTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, genericTableName GenericTableName, reqEditors ...RequestEditorFn) (*LoadGenericTableResponse, error) {
	rsp, err := c.LoadGenericTable(ctx, prefix, namespaceString, genericTableName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadGenericTableResponse(rsp)
}

// ListPoliciesWithResponse request returning *ListPoliciesResponse
func (c *ClientWithResponses) ListPoliciesWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error) {
	rsp, err := c.ListPolicies(ctx, prefix, namespaceString, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPoliciesResponse(rsp)
}

// CreatePolicyWithBodyWithResponse request with arbitrary body returning *CreatePolicyResponse
func (c *ClientWithResponses) CreatePolicyWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicyWithBody(ctx, prefix, namespaceString, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePolicyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicy(ctx, prefix, namespaceString, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

// DropPolicyWithResponse request returning *DropPolicyResponse
func (c *ClientWithResponses) DropPolicyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, params *DropPolicyParams, reqEditors ...RequestEditorFn) (*DropPolicyResponse, error) {
	rsp, err := c.DropPolicy(ctx, prefix, namespaceString, policyName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropPolicyResponse(rsp)
}

// LoadPolicyWithResponse request returning *LoadPolicyResponse
func (c *ClientWithResponses) LoadPolicyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, reqEditors ...RequestEditorFn) (*LoadPolicyResponse, error) {
	rsp, err := c.LoadPolicy(ctx, prefix, namespaceString, policyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadPolicyResponse(rsp)
}

// UpdatePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePolicyResponse
func (c *ClientWithResponses) UpdatePolicyWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicyWithBody(ctx, prefix, namespaceString, policyName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicy(ctx, prefix, namespaceString, policyName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

// DetachPolicyWithBodyWithResponse request with arbitrary body returning *DetachPolicyResponse
func (c *ClientWithResponses) DetachPolicyWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DetachPolicyResponse, error) {
	rsp, err := c.DetachPolicyWithBody(ctx, prefix, namespaceString, policyName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDetachPolicyResponse(rsp)
}

func (c *ClientWithResponses) DetachPolicyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body DetachPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DetachPolicyResponse, error) {
	rsp, err := c.DetachPolicy(ctx, prefix, namespaceString, policyName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDetachPolicyResponse(rsp)
}

// AttachPolicyWithBodyWithResponse request with arbitrary body returning *AttachPolicyResponse
func (c *ClientWithResponses) AttachPolicyWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachPolicyResponse, error) {
	rsp, err := c.AttachPolicyWithBody(ctx, prefix, namespaceString, policyName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPolicyResponse(rsp)
}

func (c *ClientWithResponses) AttachPolicyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, policyName PolicyName, body AttachPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachPolicyResponse, error) {
	rsp, err := c.AttachPolicy(ctx, prefix, namespaceString, policyName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPolicyResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// GetTokenWithBodyWithResponse request with arbitrary body returning *GetTokenResponse
func (c *ClientWithResponses) GetTokenWithBodyWithResponse(ctx context.Context, params *GetTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetTokenResponse, error) {
	rsp, err := c.GetTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenResponse(rsp)
}

func (c *ClientWithResponses) GetTokenWithFormdataBodyWithResponse(ctx context.Context, params *GetTokenParams, body GetTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetTokenResponse, error) {
	rsp, err := c.GetTokenWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenResponse(rsp)
}

// ListNamespacesWithResponse request returning *ListNamespacesResponse
func (c *ClientWithResponses) ListNamespacesWithResponse(ctx context.Context, prefix Prefix, params *ListNamespacesParams, reqEditors ...RequestEditorFn) (*ListNamespacesResponse, error) {
	rsp, err := c.ListNamespaces(ctx, prefix, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNamespacesResponse(rsp)
}

// CreateNamespaceWithBodyWithResponse request with arbitrary body returning *CreateNamespaceResponse
func (c *ClientWithResponses) CreateNamespaceWithBodyWithResponse(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNamespaceResponse, error) {
	rsp, err := c.CreateNamespaceWithBody(ctx, prefix, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNamespaceResponse(rsp)
}

func (c *ClientWithResponses) CreateNamespaceWithResponse(ctx context.Context, prefix Prefix, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNamespaceResponse, error) {
	rsp, err := c.CreateNamespace(ctx, prefix, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNamespaceResponse(rsp)
}

// DropNamespaceWithResponse request returning *DropNamespaceResponse
func (c *ClientWithResponses) DropNamespaceWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, reqEditors ...RequestEditorFn) (*DropNamespaceResponse, error) {
	rsp, err := c.DropNamespace(ctx, prefix, namespaceString, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropNamespaceResponse(rsp)
}

// LoadNamespaceMetadataWithResponse request returning *LoadNamespaceMetadataResponse
func (c *ClientWithResponses) LoadNamespaceMetadataWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, reqEditors ...RequestEditorFn) (*LoadNamespaceMetadataResponse, error) {
	rsp, err := c.LoadNamespaceMetadata(ctx, prefix, namespaceString, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadNamespaceMetadataResponse(rsp)
}

// NamespaceExistsWithResponse request returning *NamespaceExistsResponse
func (c *ClientWithResponses) NamespaceExistsWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, reqEditors ...RequestEditorFn) (*NamespaceExistsResponse, error) {
	rsp, err := c.NamespaceExists(ctx, prefix, namespaceString, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespaceExistsResponse(rsp)
}

// UpdatePropertiesWithBodyWithResponse request with arbitrary body returning *UpdatePropertiesResponse
func (c *ClientWithResponses) UpdatePropertiesWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePropertiesResponse, error) {
	rsp, err := c.UpdatePropertiesWithBody(ctx, prefix, namespaceString, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePropertiesResponse(rsp)
}

func (c *ClientWithResponses) UpdatePropertiesWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body UpdatePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePropertiesResponse, error) {
	rsp, err := c.UpdateProperties(ctx, prefix, namespaceString, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePropertiesResponse(rsp)
}

// RegisterTableWithBodyWithResponse request with arbitrary body returning *RegisterTableResponse
func (c *ClientWithResponses) RegisterTableWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterTableResponse, error) {
	rsp, err := c.RegisterTableWithBody(ctx, prefix, namespaceString, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterTableResponse(rsp)
}

func (c *ClientWithResponses) RegisterTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body RegisterTableJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterTableResponse, error) {
	rsp, err := c.RegisterTable(ctx, prefix, namespaceString, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterTableResponse(rsp)
}

// ListTablesWithResponse request returning *ListTablesResponse
func (c *ClientWithResponses) ListTablesWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListTablesParams, reqEditors ...RequestEditorFn) (*ListTablesResponse, error) {
	rsp, err := c.ListTables(ctx, prefix, namespaceString, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTablesResponse(rsp)
}

// CreateTableWithBodyWithResponse request with arbitrary body returning *CreateTableResponse
func (c *ClientWithResponses) CreateTableWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTableWithBody(ctx, prefix, namespaceString, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

func (c *ClientWithResponses) CreateTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTable(ctx, prefix, namespaceString, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

// DropTableWithResponse request returning *DropTableResponse
func (c *ClientWithResponses) DropTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, params *DropTableParams, reqEditors ...RequestEditorFn) (*DropTableResponse, error) {
	rsp, err := c.DropTable(ctx, prefix, namespaceString, table, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropTableResponse(rsp)
}

// LoadTableWithResponse request returning *LoadTableResponse
func (c *ClientWithResponses) LoadTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, params *LoadTableParams, reqEditors ...RequestEditorFn) (*LoadTableResponse, error) {
	rsp, err := c.LoadTable(ctx, prefix, namespaceString, table, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadTableResponse(rsp)
}

// TableExistsWithResponse request returning *TableExistsResponse
func (c *ClientWithResponses) TableExistsWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, reqEditors ...RequestEditorFn) (*TableExistsResponse, error) {
	rsp, err := c.TableExists(ctx, prefix, namespaceString, table, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTableExistsResponse(rsp)
}

// UpdateTableWithBodyWithResponse request with arbitrary body returning *UpdateTableResponse
func (c *ClientWithResponses) UpdateTableWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTableResponse, error) {
	rsp, err := c.UpdateTableWithBody(ctx, prefix, namespaceString, table, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTableResponse(rsp)
}

func (c *ClientWithResponses) UpdateTableWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTableResponse, error) {
	rsp, err := c.UpdateTable(ctx, prefix, namespaceString, table, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTableResponse(rsp)
}

// LoadCredentialsWithResponse request returning *LoadCredentialsResponse
func (c *ClientWithResponses) LoadCredentialsWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, reqEditors ...RequestEditorFn) (*LoadCredentialsResponse, error) {
	rsp, err := c.LoadCredentials(ctx, prefix, namespaceString, table, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadCredentialsResponse(rsp)
}

// ReportMetricsWithBodyWithResponse request with arbitrary body returning *ReportMetricsResponse
func (c *ClientWithResponses) ReportMetricsWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReportMetricsResponse, error) {
	rsp, err := c.ReportMetricsWithBody(ctx, prefix, namespaceString, table, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportMetricsResponse(rsp)
}

func (c *ClientWithResponses) ReportMetricsWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, body ReportMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportMetricsResponse, error) {
	rsp, err := c.ReportMetrics(ctx, prefix, namespaceString, table, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportMetricsResponse(rsp)
}

// SendNotificationWithBodyWithResponse request with arbitrary body returning *SendNotificationResponse
func (c *ClientWithResponses) SendNotificationWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendNotificationResponse, error) {
	rsp, err := c.SendNotificationWithBody(ctx, prefix, namespaceString, table, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendNotificationResponse(rsp)
}

func (c *ClientWithResponses) SendNotificationWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, table Table, body SendNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*SendNotificationResponse, error) {
	rsp, err := c.SendNotification(ctx, prefix, namespaceString, table, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendNotificationResponse(rsp)
}

// ListViewsWithResponse request returning *ListViewsResponse
func (c *ClientWithResponses) ListViewsWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, params *ListViewsParams, reqEditors ...RequestEditorFn) (*ListViewsResponse, error) {
	rsp, err := c.ListViews(ctx, prefix, namespaceString, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListViewsResponse(rsp)
}

// CreateViewWithBodyWithResponse request with arbitrary body returning *CreateViewResponse
func (c *ClientWithResponses) CreateViewWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateViewResponse, error) {
	rsp, err := c.CreateViewWithBody(ctx, prefix, namespaceString, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateViewResponse(rsp)
}

func (c *ClientWithResponses) CreateViewWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, body CreateViewJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateViewResponse, error) {
	rsp, err := c.CreateView(ctx, prefix, namespaceString, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateViewResponse(rsp)
}

// DropViewWithResponse request returning *DropViewResponse
func (c *ClientWithResponses) DropViewWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, reqEditors ...RequestEditorFn) (*DropViewResponse, error) {
	rsp, err := c.DropView(ctx, prefix, namespaceString, view, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDropViewResponse(rsp)
}

// LoadViewWithResponse request returning *LoadViewResponse
func (c *ClientWithResponses) LoadViewWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, reqEditors ...RequestEditorFn) (*LoadViewResponse, error) {
	rsp, err := c.LoadView(ctx, prefix, namespaceString, view, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadViewResponse(rsp)
}

// ViewExistsWithResponse request returning *ViewExistsResponse
func (c *ClientWithResponses) ViewExistsWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, reqEditors ...RequestEditorFn) (*ViewExistsResponse, error) {
	rsp, err := c.ViewExists(ctx, prefix, namespaceString, view, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseViewExistsResponse(rsp)
}

// ReplaceViewWithBodyWithResponse request with arbitrary body returning *ReplaceViewResponse
func (c *ClientWithResponses) ReplaceViewWithBodyWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceViewResponse, error) {
	rsp, err := c.ReplaceViewWithBody(ctx, prefix, namespaceString, view, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceViewResponse(rsp)
}

func (c *ClientWithResponses) ReplaceViewWithResponse(ctx context.Context, prefix Prefix, namespaceString NamespaceString, view View, body ReplaceViewJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceViewResponse, error) {
	rsp, err := c.ReplaceView(ctx, prefix, namespaceString, view, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceViewResponse(rsp)
}

// RenameTableWithBodyWithResponse request with arbitrary body returning *RenameTableResponse
func (c *ClientWithResponses) RenameTableWithBodyWithResponse(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameTableResponse, error) {
	rsp, err := c.RenameTableWithBody(ctx, prefix, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameTableResponse(rsp)
}

func (c *ClientWithResponses) RenameTableWithResponse(ctx context.Context, prefix Prefix, body RenameTableJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameTableResponse, error) {
	rsp, err := c.RenameTable(ctx, prefix, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameTableResponse(rsp)
}

// CommitTransactionWithBodyWithResponse request with arbitrary body returning *CommitTransactionResponse
func (c *ClientWithResponses) CommitTransactionWithBodyWithResponse(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitTransactionResponse, error) {
	rsp, err := c.CommitTransactionWithBody(ctx, prefix, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitTransactionResponse(rsp)
}

func (c *ClientWithResponses) CommitTransactionWithResponse(ctx context.Context, prefix Prefix, body CommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitTransactionResponse, error) {
	rsp, err := c.CommitTransaction(ctx, prefix, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitTransactionResponse(rsp)
}

// RenameViewWithBodyWithResponse request with arbitrary body returning *RenameViewResponse
func (c *ClientWithResponses) RenameViewWithBodyWithResponse(ctx context.Context, prefix Prefix, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameViewResponse, error) {
	rsp, err := c.RenameViewWithBody(ctx, prefix, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameViewResponse(rsp)
}

func (c *ClientWithResponses) RenameViewWithResponse(ctx context.Context, prefix Prefix, body RenameViewJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameViewResponse, error) {
	rsp, err := c.RenameView(ctx, prefix, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameViewResponse(rsp)
}

// ParseGetApplicablePoliciesResponse parses an HTTP response from a GetApplicablePoliciesWithResponse call
func ParseGetApplicablePoliciesResponse(rsp *http.Response) (*GetApplicablePoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicablePoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetApplicablePoliciesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseListGenericTablesResponse parses an HTTP response from a ListGenericTablesWithResponse call
func ParseListGenericTablesResponse(rsp *http.Response) (*ListGenericTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGenericTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListGenericTablesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCreateGenericTableResponse parses an HTTP response from a CreateGenericTableWithResponse call
func ParseCreateGenericTableResponse(rsp *http.Response) (*CreateGenericTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGenericTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateGenericTableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDropGenericTableResponse parses an HTTP response from a DropGenericTableWithResponse call
func ParseDropGenericTableResponse(rsp *http.Response) (*DropGenericTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DropGenericTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseLoadGenericTableResponse parses an HTTP response from a LoadGenericTableWithResponse call
func ParseLoadGenericTableResponse(rsp *http.Response) (*LoadGenericTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadGenericTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadGenericTableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseListPoliciesResponse parses an HTTP response from a ListPoliciesWithResponse call
func ParseListPoliciesResponse(rsp *http.Response) (*ListPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPoliciesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCreatePolicyResponse parses an HTTP response from a CreatePolicyWithResponse call
func ParseCreatePolicyResponse(rsp *http.Response) (*CreatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDropPolicyResponse parses an HTTP response from a DropPolicyWithResponse call
func ParseDropPolicyResponse(rsp *http.Response) (*DropPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DropPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseLoadPolicyResponse parses an HTTP response from a LoadPolicyWithResponse call
func ParseLoadPolicyResponse(rsp *http.Response) (*LoadPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseUpdatePolicyResponse parses an HTTP response from a UpdatePolicyWithResponse call
func ParseUpdatePolicyResponse(rsp *http.Response) (*UpdatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdatePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDetachPolicyResponse parses an HTTP response from a DetachPolicyWithResponse call
func ParseDetachPolicyResponse(rsp *http.Response) (*DetachPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DetachPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseAttachPolicyResponse parses an HTTP response from a AttachPolicyWithResponse call
func ParseAttachPolicyResponse(rsp *http.Response) (*AttachPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CatalogConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetTokenResponse parses an HTTP response from a GetTokenWithResponse call
func ParseGetTokenResponse(rsp *http.Response) (*GetTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest OAuthErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest OAuthErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseListNamespacesResponse parses an HTTP response from a ListNamespacesWithResponse call
func ParseListNamespacesResponse(rsp *http.Response) (*ListNamespacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListNamespacesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCreateNamespaceResponse parses an HTTP response from a CreateNamespaceWithResponse call
func ParseCreateNamespaceResponse(rsp *http.Response) (*CreateNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateNamespaceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest UnsupportedOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDropNamespaceResponse parses an HTTP response from a DropNamespaceWithResponse call
func ParseDropNamespaceResponse(rsp *http.Response) (*DropNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DropNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseLoadNamespaceMetadataResponse parses an HTTP response from a LoadNamespaceMetadataWithResponse call
func ParseLoadNamespaceMetadataResponse(rsp *http.Response) (*LoadNamespaceMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadNamespaceMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetNamespaceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseNamespaceExistsResponse parses an HTTP response from a NamespaceExistsWithResponse call
func ParseNamespaceExistsResponse(rsp *http.Response) (*NamespaceExistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespaceExistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseUpdatePropertiesResponse parses an HTTP response from a UpdatePropertiesWithResponse call
func ParseUpdatePropertiesResponse(rsp *http.Response) (*UpdatePropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateNamespacePropertiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest UnsupportedOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseRegisterTableResponse parses an HTTP response from a RegisterTableWithResponse call
func ParseRegisterTableResponse(rsp *http.Response) (*RegisterTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadTableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseListTablesResponse parses an HTTP response from a ListTablesWithResponse call
func ParseListTablesResponse(rsp *http.Response) (*ListTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTablesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCreateTableResponse parses an HTTP response from a CreateTableWithResponse call
func ParseCreateTableResponse(rsp *http.Response) (*CreateTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateTableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDropTableResponse parses an HTTP response from a DropTableWithResponse call
func ParseDropTableResponse(rsp *http.Response) (*DropTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DropTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseLoadTableResponse parses an HTTP response from a LoadTableWithResponse call
func ParseLoadTableResponse(rsp *http.Response) (*LoadTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadTableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseTableExistsResponse parses an HTTP response from a TableExistsWithResponse call
func ParseTableExistsResponse(rsp *http.Response) (*TableExistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TableExistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseUpdateTableResponse parses an HTTP response from a UpdateTableWithResponse call
func ParseUpdateTableResponse(rsp *http.Response) (*UpdateTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitTableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseLoadCredentialsResponse parses an HTTP response from a LoadCredentialsWithResponse call
func ParseLoadCredentialsResponse(rsp *http.Response) (*LoadCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadCredentialsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseReportMetricsResponse parses an HTTP response from a ReportMetricsWithResponse call
func ParseReportMetricsResponse(rsp *http.Response) (*ReportMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReportMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseSendNotificationResponse parses an HTTP response from a SendNotificationWithResponse call
func ParseSendNotificationResponse(rsp *http.Response) (*SendNotificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseListViewsResponse parses an HTTP response from a ListViewsWithResponse call
func ParseListViewsResponse(rsp *http.Response) (*ListViewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListViewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTablesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCreateViewResponse parses an HTTP response from a CreateViewWithResponse call
func ParseCreateViewResponse(rsp *http.Response) (*CreateViewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateViewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadViewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDropViewResponse parses an HTTP response from a DropViewWithResponse call
func ParseDropViewResponse(rsp *http.Response) (*DropViewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DropViewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseLoadViewResponse parses an HTTP response from a LoadViewWithResponse call
func ParseLoadViewResponse(rsp *http.Response) (*LoadViewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadViewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadViewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseViewExistsResponse parses an HTTP response from a ViewExistsWithResponse call
func ParseViewExistsResponse(rsp *http.Response) (*ViewExistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ViewExistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseReplaceViewResponse parses an HTTP response from a ReplaceViewWithResponse call
func ParseReplaceViewResponse(rsp *http.Response) (*ReplaceViewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceViewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadViewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseRenameTableResponse parses an HTTP response from a RenameTableWithResponse call
func ParseRenameTableResponse(rsp *http.Response) (*RenameTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RenameTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest UnsupportedOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCommitTransactionResponse parses an HTTP response from a CommitTransactionWithResponse call
func ParseCommitTransactionResponse(rsp *http.Response) (*CommitTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest IcebergErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseRenameViewResponse parses an HTTP response from a RenameViewWithResponse call
func ParseRenameViewResponse(rsp *http.Response) (*RenameViewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RenameViewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest UnsupportedOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 419:
		var dest AuthenticationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON419 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest ServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}
